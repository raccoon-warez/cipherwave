{"version":3,"file":"chunk-legacy-C_8oj4N8.js","sources":["../../src/managers/file-manager.js","../../src/managers/voice-manager.js"],"sourcesContent":["// CipherWave File Manager - Dynamically loaded for file sharing features\n// Only loaded when file sharing is needed to reduce initial bundle size\n\nexport class FileManager {\n    constructor() {\n        this.maxFileSize = 50 * 1024 * 1024; // 50MB\n        this.allowedTypes = {\n            images: ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'],\n            videos: ['video/mp4', 'video/webm', 'video/ogg', 'video/mov', 'video/avi'],\n            audio: ['audio/mp3', 'audio/wav', 'audio/ogg', 'audio/webm', 'audio/m4a'],\n            documents: ['application/pdf', 'text/plain', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],\n            archives: ['application/zip', 'application/x-rar-compressed', 'application/x-7z-compressed']\n        };\n        \n        this.uploadQueue = [];\n        this.activeUploads = new Map();\n        this.compressionSettings = {\n            image: { quality: 0.8, maxWidth: 1920, maxHeight: 1080 },\n            video: { quality: 0.7, maxWidth: 1280, maxHeight: 720 }\n        };\n        \n        this.chunkSize = 64 * 1024; // 64KB chunks for large files\n        this.thumbnailSize = { width: 300, height: 200 };\n        \n        console.log('📁 File manager loaded');\n    }\n    \n    async setup() {\n        console.log('📁 Setting up file sharing system...');\n        \n        this.setupDragAndDrop();\n        this.setupFileInput();\n        this.setupClipboardPaste();\n        this.createFileUploadUI();\n    }\n    \n    setupDragAndDrop() {\n        const dropZone = document.body;\n        \n        dropZone.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            dropZone.classList.add('drag-over');\n        });\n        \n        dropZone.addEventListener('dragleave', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (!dropZone.contains(e.relatedTarget)) {\n                dropZone.classList.remove('drag-over');\n            }\n        });\n        \n        dropZone.addEventListener('drop', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            dropZone.classList.remove('drag-over');\n            \n            const files = Array.from(e.dataTransfer.files);\n            this.handleFileSelection(files);\n        });\n    }\n    \n    setupFileInput() {\n        // Create hidden file input\n        const fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.multiple = true;\n        fileInput.style.display = 'none';\n        fileInput.id = 'fileInput';\n        \n        fileInput.addEventListener('change', (e) => {\n            const files = Array.from(e.target.files);\n            this.handleFileSelection(files);\n        });\n        \n        document.body.appendChild(fileInput);\n        \n        // Add file share button if it doesn't exist\n        this.createFileShareButton();\n    }\n    \n    setupClipboardPaste() {\n        document.addEventListener('paste', (e) => {\n            const items = Array.from(e.clipboardData.items);\n            const files = items\n                .filter(item => item.kind === 'file')\n                .map(item => item.getAsFile());\n            \n            if (files.length > 0) {\n                e.preventDefault();\n                this.handleFileSelection(files);\n            }\n        });\n    }\n    \n    createFileShareButton() {\n        const chatPanel = document.getElementById('chat-panel');\n        if (!chatPanel || document.getElementById('fileShareBtn')) {\n            return;\n        }\n        \n        const messageInputGroup = chatPanel.querySelector('.message-input-group');\n        if (!messageInputGroup) {\n            return;\n        }\n        \n        const fileBtn = document.createElement('button');\n        fileBtn.id = 'fileShareBtn';\n        fileBtn.className = 'btn btn-secondary';\n        fileBtn.innerHTML = '<i class=\"fas fa-paperclip\"></i>';\n        fileBtn.title = 'Share file';\n        \n        fileBtn.addEventListener('click', () => {\n            document.getElementById('fileInput').click();\n        });\n        \n        messageInputGroup.insertBefore(fileBtn, messageInputGroup.lastElementChild);\n    }\n    \n    createFileUploadUI() {\n        // Add drag-drop overlay styles\n        if (!document.getElementById('fileManagerStyles')) {\n            const styles = document.createElement('style');\n            styles.id = 'fileManagerStyles';\n            styles.textContent = `\n                .drag-over::after {\n                    content: \"Drop files to send\";\n                    position: fixed;\n                    top: 0;\n                    left: 0;\n                    width: 100%;\n                    height: 100%;\n                    background: rgba(0, 136, 204, 0.8);\n                    color: white;\n                    display: flex;\n                    align-items: center;\n                    justify-content: center;\n                    font-size: 2rem;\n                    z-index: 10000;\n                    pointer-events: none;\n                }\n                \n                .file-upload-progress {\n                    background: #1a1f29;\n                    border: 1px solid #2a3441;\n                    border-radius: 8px;\n                    padding: 15px;\n                    margin: 10px 0;\n                    max-width: 400px;\n                }\n                \n                .file-upload-info {\n                    display: flex;\n                    align-items: center;\n                    margin-bottom: 10px;\n                }\n                \n                .file-upload-icon {\n                    font-size: 2rem;\n                    margin-right: 15px;\n                    color: #0088cc;\n                }\n                \n                .file-upload-details h4 {\n                    margin: 0 0 5px 0;\n                    color: #ffffff;\n                }\n                \n                .file-upload-details p {\n                    margin: 0;\n                    color: #8899a6;\n                    font-size: 0.9rem;\n                }\n                \n                .file-upload-progress-bar {\n                    width: 100%;\n                    height: 6px;\n                    background: #2a3441;\n                    border-radius: 3px;\n                    overflow: hidden;\n                }\n                \n                .file-upload-progress-fill {\n                    height: 100%;\n                    background: #0088cc;\n                    transition: width 0.3s ease;\n                }\n                \n                .file-preview {\n                    max-width: 200px;\n                    max-height: 200px;\n                    border-radius: 8px;\n                    margin: 10px 0;\n                }\n            `;\n            document.head.appendChild(styles);\n        }\n    }\n    \n    async handleFileSelection(files) {\n        console.log(`📁 Processing ${files.length} file(s)`);\n        \n        for (const file of files) {\n            if (this.validateFile(file)) {\n                await this.processFile(file);\n            }\n        }\n    }\n    \n    validateFile(file) {\n        // Check file size\n        if (file.size > this.maxFileSize) {\n            this.showError(`File \"${file.name}\" is too large (max ${this.maxFileSize / 1024 / 1024}MB)`);\n            return false;\n        }\n        \n        // Check file type\n        const isAllowed = Object.values(this.allowedTypes)\n            .flat()\n            .some(type => file.type === type || file.type.startsWith(type.split('/')[0]));\n        \n        if (!isAllowed) {\n            this.showError(`File type \"${file.type}\" is not allowed`);\n            return false;\n        }\n        \n        return true;\n    }\n    \n    async processFile(file) {\n        const fileId = this.generateFileId();\n        const uploadInfo = {\n            id: fileId,\n            file: file,\n            status: 'processing',\n            progress: 0,\n            chunks: [],\n            thumbnail: null\n        };\n        \n        this.activeUploads.set(fileId, uploadInfo);\n        \n        try {\n            // Show upload progress UI\n            this.showUploadProgress(uploadInfo);\n            \n            // Generate thumbnail for images/videos\n            if (file.type.startsWith('image/') || file.type.startsWith('video/')) {\n                uploadInfo.thumbnail = await this.generateThumbnail(file);\n            }\n            \n            // Compress if needed\n            const processedFile = await this.compressFile(file);\n            \n            // Split into chunks\n            uploadInfo.chunks = await this.splitFileIntoChunks(processedFile);\n            uploadInfo.status = 'ready';\n            \n            // Send file metadata first\n            await this.sendFileMetadata(uploadInfo);\n            \n            // Send chunks\n            await this.sendFileChunks(uploadInfo);\n            \n            uploadInfo.status = 'completed';\n            this.updateUploadProgress(uploadInfo);\n            \n            console.log(`✅ File \"${file.name}\" sent successfully`);\n            \n        } catch (error) {\n            console.error(`❌ Failed to process file \"${file.name}\":`, error);\n            uploadInfo.status = 'error';\n            uploadInfo.error = error.message;\n            this.updateUploadProgress(uploadInfo);\n        }\n    }\n    \n    async generateThumbnail(file) {\n        return new Promise((resolve) => {\n            if (file.type.startsWith('image/')) {\n                const img = new Image();\n                img.onload = () => {\n                    const canvas = document.createElement('canvas');\n                    const ctx = canvas.getContext('2d');\n                    \n                    // Calculate dimensions\n                    const { width, height } = this.calculateThumbnailSize(img.width, img.height);\n                    canvas.width = width;\n                    canvas.height = height;\n                    \n                    // Draw thumbnail\n                    ctx.drawImage(img, 0, 0, width, height);\n                    \n                    resolve(canvas.toDataURL('image/jpeg', 0.8));\n                };\n                img.src = URL.createObjectURL(file);\n            } else {\n                resolve(null);\n            }\n        });\n    }\n    \n    calculateThumbnailSize(originalWidth, originalHeight) {\n        const { width: maxWidth, height: maxHeight } = this.thumbnailSize;\n        \n        const ratio = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);\n        \n        return {\n            width: Math.round(originalWidth * ratio),\n            height: Math.round(originalHeight * ratio)\n        };\n    }\n    \n    async compressFile(file) {\n        // For now, return the original file\n        // Compression can be implemented later for specific file types\n        return file;\n    }\n    \n    async splitFileIntoChunks(file) {\n        const chunks = [];\n        const totalChunks = Math.ceil(file.size / this.chunkSize);\n        \n        for (let i = 0; i < totalChunks; i++) {\n            const start = i * this.chunkSize;\n            const end = Math.min(start + this.chunkSize, file.size);\n            const chunk = file.slice(start, end);\n            \n            chunks.push({\n                index: i,\n                data: await this.fileToBase64(chunk),\n                size: chunk.size\n            });\n        }\n        \n        return chunks;\n    }\n    \n    async fileToBase64(file) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.onerror = reject;\n            reader.readAsDataURL(file);\n        });\n    }\n    \n    async sendFileMetadata(uploadInfo) {\n        const metadata = {\n            type: 'file_metadata',\n            fileId: uploadInfo.id,\n            name: uploadInfo.file.name,\n            size: uploadInfo.file.size,\n            type: uploadInfo.file.type,\n            chunks: uploadInfo.chunks.length,\n            thumbnail: uploadInfo.thumbnail,\n            timestamp: Date.now()\n        };\n        \n        // Emit to connection manager\n        if (window.cipherWave && window.cipherWave.connectionManager) {\n            await window.cipherWave.connectionManager.sendData(metadata);\n        }\n    }\n    \n    async sendFileChunks(uploadInfo) {\n        for (let i = 0; i < uploadInfo.chunks.length; i++) {\n            const chunk = uploadInfo.chunks[i];\n            \n            const chunkMessage = {\n                type: 'file_chunk',\n                fileId: uploadInfo.id,\n                chunkIndex: chunk.index,\n                data: chunk.data,\n                isLast: i === uploadInfo.chunks.length - 1\n            };\n            \n            // Send chunk\n            if (window.cipherWave && window.cipherWave.connectionManager) {\n                await window.cipherWave.connectionManager.sendData(chunkMessage);\n            }\n            \n            // Update progress\n            uploadInfo.progress = ((i + 1) / uploadInfo.chunks.length) * 100;\n            this.updateUploadProgress(uploadInfo);\n            \n            // Small delay to prevent overwhelming the connection\n            await new Promise(resolve => setTimeout(resolve, 10));\n        }\n    }\n    \n    showUploadProgress(uploadInfo) {\n        const messagesContainer = document.getElementById('messages');\n        if (!messagesContainer) return;\n        \n        const progressElement = document.createElement('div');\n        progressElement.className = 'file-upload-progress';\n        progressElement.id = `upload-${uploadInfo.id}`;\n        \n        progressElement.innerHTML = `\n            <div class=\"file-upload-info\">\n                <div class=\"file-upload-icon\">\n                    <i class=\"fas fa-file\"></i>\n                </div>\n                <div class=\"file-upload-details\">\n                    <h4>${uploadInfo.file.name}</h4>\n                    <p>${this.formatFileSize(uploadInfo.file.size)} • ${uploadInfo.file.type}</p>\n                </div>\n            </div>\n            <div class=\"file-upload-progress-bar\">\n                <div class=\"file-upload-progress-fill\" style=\"width: 0%\"></div>\n            </div>\n        `;\n        \n        messagesContainer.appendChild(progressElement);\n        messagesContainer.scrollTop = messagesContainer.scrollHeight;\n    }\n    \n    updateUploadProgress(uploadInfo) {\n        const progressElement = document.getElementById(`upload-${uploadInfo.id}`);\n        if (!progressElement) return;\n        \n        const progressFill = progressElement.querySelector('.file-upload-progress-fill');\n        if (progressFill) {\n            progressFill.style.width = `${uploadInfo.progress}%`;\n        }\n        \n        if (uploadInfo.status === 'completed') {\n            setTimeout(() => {\n                if (progressElement.parentElement) {\n                    progressElement.remove();\n                }\n            }, 2000);\n        } else if (uploadInfo.status === 'error') {\n            progressElement.style.borderColor = '#ff6b6b';\n            const details = progressElement.querySelector('.file-upload-details p');\n            if (details) {\n                details.textContent = `Error: ${uploadInfo.error}`;\n                details.style.color = '#ff6b6b';\n            }\n        }\n    }\n    \n    generateFileId() {\n        return `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    formatFileSize(bytes) {\n        if (bytes === 0) return '0 Bytes';\n        \n        const k = 1024;\n        const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        \n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n    }\n    \n    showError(message) {\n        if (window.cipherWave && window.cipherWave.uiManager) {\n            window.cipherWave.uiManager.showError(message);\n        } else {\n            console.error(message);\n        }\n    }\n    \n    destroy() {\n        this.activeUploads.clear();\n        this.uploadQueue = [];\n        \n        // Remove file input\n        const fileInput = document.getElementById('fileInput');\n        if (fileInput) {\n            fileInput.remove();\n        }\n        \n        // Remove file share button\n        const fileBtn = document.getElementById('fileShareBtn');\n        if (fileBtn) {\n            fileBtn.remove();\n        }\n        \n        // Remove styles\n        const styles = document.getElementById('fileManagerStyles');\n        if (styles) {\n            styles.remove();\n        }\n        \n        console.log('🗑️ File manager destroyed');\n    }\n}","// CipherWave Voice Manager - Dynamically loaded for voice message features\n// Only loaded when voice messaging is needed to reduce initial bundle size\n\nexport class VoiceManager {\n    constructor() {\n        this.isRecording = false;\n        this.mediaRecorder = null;\n        this.audioContext = null;\n        this.analyser = null;\n        this.microphone = null;\n        this.recordedChunks = [];\n        this.recordingStartTime = null;\n        this.recordingDuration = 0;\n        this.maxRecordingTime = 300000; // 5 minutes\n        this.recordingTimer = null;\n        this.waveformCanvas = null;\n        this.waveformContext = null;\n        this.animationFrame = null;\n        this.supportedMimeTypes = ['audio/webm', 'audio/mp4', 'audio/wav'];\n        this.selectedMimeType = null;\n        this.voiceMessages = new Map();\n        \n        // Voice message UI elements\n        this.voiceButton = null;\n        this.recordingIndicator = null;\n        this.waveformContainer = null;\n        \n        // Playback states\n        this.currentlyPlaying = null;\n        this.isPlaying = false;\n        \n        // Permissions\n        this.microphoneAccess = false;\n        \n        // Compression settings\n        this.compressionOptions = {\n            mimeType: 'audio/webm;codecs=opus',\n            audioBitsPerSecond: 128000 // 128 kbps\n        };\n        \n        console.log('🎤 Voice manager loaded');\n    }\n    \n    async init() {\n        console.log('🎤 Initializing voice messaging system...');\n        \n        try {\n            await this.requestMicrophoneAccess();\n            this.detectSupportedMimeType();\n            this.createVoiceUI();\n            \n            console.log('✅ Voice manager initialized successfully');\n            \n        } catch (error) {\n            console.error('❌ Failed to initialize voice manager:', error);\n            throw error;\n        }\n    }\n    \n    async requestMicrophoneAccess() {\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia({ \n                audio: {\n                    echoCancellation: true,\n                    noiseSuppression: true,\n                    autoGainControl: true\n                } \n            });\n            \n            this.microphoneAccess = true;\n            \n            // Stop the stream for now, we'll request it again when recording\n            stream.getTracks().forEach(track => track.stop());\n            \n            console.log('🎤 Microphone access granted');\n            \n        } catch (error) {\n            console.error('Microphone access denied:', error);\n            throw new Error('Microphone access is required for voice messages');\n        }\n    }\n    \n    detectSupportedMimeType() {\n        for (const mimeType of this.supportedMimeTypes) {\n            if (MediaRecorder.isTypeSupported(mimeType)) {\n                this.selectedMimeType = mimeType;\n                console.log(`🎤 Using audio format: ${mimeType}`);\n                break;\n            }\n        }\n        \n        if (!this.selectedMimeType) {\n            throw new Error('No supported audio format found');\n        }\n    }\n    \n    createVoiceUI() {\n        const chatPanel = document.getElementById('chat-panel');\n        if (!chatPanel || document.getElementById('voiceBtn')) {\n            return;\n        }\n        \n        const messageInputGroup = chatPanel.querySelector('.message-input-group');\n        if (!messageInputGroup) {\n            return;\n        }\n        \n        // Create voice button\n        this.voiceButton = document.createElement('button');\n        this.voiceButton.id = 'voiceBtn';\n        this.voiceButton.className = 'btn btn-secondary voice-btn';\n        this.voiceButton.innerHTML = '<i class=\"fas fa-microphone\"></i>';\n        this.voiceButton.title = 'Record voice message';\n        \n        // Add event listeners\n        this.voiceButton.addEventListener('mousedown', (e) => {\n            e.preventDefault();\n            this.startRecording();\n        });\n        \n        this.voiceButton.addEventListener('mouseup', (e) => {\n            e.preventDefault();\n            this.stopRecording();\n        });\n        \n        this.voiceButton.addEventListener('mouseleave', (e) => {\n            if (this.isRecording) {\n                this.stopRecording();\n            }\n        });\n        \n        // Touch events for mobile\n        this.voiceButton.addEventListener('touchstart', (e) => {\n            e.preventDefault();\n            this.startRecording();\n        });\n        \n        this.voiceButton.addEventListener('touchend', (e) => {\n            e.preventDefault();\n            this.stopRecording();\n        });\n        \n        messageInputGroup.insertBefore(this.voiceButton, messageInputGroup.lastElementChild);\n        \n        // Add voice UI styles\n        this.addVoiceStyles();\n    }\n    \n    addVoiceStyles() {\n        if (document.getElementById('voiceManagerStyles')) {\n            return;\n        }\n        \n        const styles = document.createElement('style');\n        styles.id = 'voiceManagerStyles';\n        styles.textContent = `\n            .voice-btn {\n                position: relative;\n                transition: all 0.3s ease;\n            }\n            \n            .voice-btn.recording {\n                background: #ff4757 !important;\n                animation: pulse 1s infinite;\n            }\n            \n            @keyframes pulse {\n                0% { transform: scale(1); }\n                50% { transform: scale(1.1); }\n                100% { transform: scale(1); }\n            }\n            \n            .voice-recording-overlay {\n                position: fixed;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background: rgba(0, 0, 0, 0.8);\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                z-index: 10000;\n                flex-direction: column;\n            }\n            \n            .voice-recording-content {\n                background: #1a1f29;\n                border-radius: 20px;\n                padding: 40px;\n                text-align: center;\n                border: 2px solid #ff4757;\n            }\n            \n            .voice-recording-icon {\n                font-size: 4rem;\n                color: #ff4757;\n                margin-bottom: 20px;\n                animation: pulse 1s infinite;\n            }\n            \n            .voice-recording-time {\n                font-size: 2rem;\n                color: #ffffff;\n                margin-bottom: 10px;\n                font-family: monospace;\n            }\n            \n            .voice-recording-instruction {\n                color: #8899a6;\n                font-size: 1.1rem;\n            }\n            \n            .voice-waveform {\n                width: 300px;\n                height: 60px;\n                margin: 20px auto;\n                background: #2a3441;\n                border-radius: 30px;\n            }\n            \n            .voice-message {\n                display: flex;\n                align-items: center;\n                background: #2a3441;\n                border-radius: 20px;\n                padding: 10px 15px;\n                margin: 5px 0;\n                max-width: 250px;\n            }\n            \n            .voice-message-play {\n                background: #0088cc;\n                border: none;\n                border-radius: 50%;\n                width: 40px;\n                height: 40px;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                color: white;\n                cursor: pointer;\n                margin-right: 10px;\n            }\n            \n            .voice-message-duration {\n                color: #8899a6;\n                font-size: 0.9rem;\n                font-family: monospace;\n            }\n            \n            .voice-message-waveform {\n                flex: 1;\n                height: 30px;\n                margin: 0 10px;\n                background: #1a1f29;\n                border-radius: 15px;\n                position: relative;\n            }\n        `;\n        \n        document.head.appendChild(styles);\n    }\n    \n    async startRecording() {\n        if (this.isRecording || !this.microphoneAccess) {\n            return;\n        }\n        \n        console.log('🎤 Starting voice recording...');\n        \n        try {\n            // Get microphone stream\n            const stream = await navigator.mediaDevices.getUserMedia({ \n                audio: {\n                    echoCancellation: true,\n                    noiseSuppression: true,\n                    autoGainControl: true\n                } \n            });\n            \n            // Set up audio context for waveform\n            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            this.analyser = this.audioContext.createAnalyser();\n            this.microphone = this.audioContext.createMediaStreamSource(stream);\n            this.microphone.connect(this.analyser);\n            \n            this.analyser.fftSize = 256;\n            \n            // Set up media recorder\n            this.mediaRecorder = new MediaRecorder(stream, {\n                mimeType: this.selectedMimeType,\n                audioBitsPerSecond: this.compressionOptions.audioBitsPerSecond\n            });\n            \n            this.recordedChunks = [];\n            \n            this.mediaRecorder.ondataavailable = (event) => {\n                if (event.data.size > 0) {\n                    this.recordedChunks.push(event.data);\n                }\n            };\n            \n            this.mediaRecorder.onstop = () => {\n                this.processRecordedAudio();\n            };\n            \n            // Start recording\n            this.mediaRecorder.start();\n            this.isRecording = true;\n            this.recordingStartTime = Date.now();\n            \n            // Update UI\n            this.showRecordingUI();\n            this.voiceButton.classList.add('recording');\n            \n            // Start waveform animation\n            this.startWaveformAnimation();\n            \n            // Start timer\n            this.startRecordingTimer();\n            \n        } catch (error) {\n            console.error('Failed to start recording:', error);\n            this.showError('Failed to start voice recording');\n        }\n    }\n    \n    stopRecording() {\n        if (!this.isRecording) {\n            return;\n        }\n        \n        console.log('🎤 Stopping voice recording...');\n        \n        this.isRecording = false;\n        this.recordingDuration = Date.now() - this.recordingStartTime;\n        \n        // Stop media recorder\n        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {\n            this.mediaRecorder.stop();\n        }\n        \n        // Stop microphone stream\n        if (this.microphone && this.microphone.stream) {\n            this.microphone.stream.getTracks().forEach(track => track.stop());\n        }\n        \n        // Clean up audio context\n        if (this.audioContext) {\n            this.audioContext.close();\n            this.audioContext = null;\n        }\n        \n        // Update UI\n        this.hideRecordingUI();\n        this.voiceButton.classList.remove('recording');\n        \n        // Stop waveform animation\n        this.stopWaveformAnimation();\n        \n        // Stop timer\n        this.stopRecordingTimer();\n    }\n    \n    showRecordingUI() {\n        if (document.getElementById('voiceRecordingOverlay')) {\n            return;\n        }\n        \n        const overlay = document.createElement('div');\n        overlay.id = 'voiceRecordingOverlay';\n        overlay.className = 'voice-recording-overlay';\n        \n        overlay.innerHTML = `\n            <div class=\"voice-recording-content\">\n                <div class=\"voice-recording-icon\">\n                    <i class=\"fas fa-microphone\"></i>\n                </div>\n                <div class=\"voice-recording-time\" id=\"recordingTime\">0:00</div>\n                <canvas class=\"voice-waveform\" id=\"recordingWaveform\" width=\"300\" height=\"60\"></canvas>\n                <div class=\"voice-recording-instruction\">Hold to record, release to send</div>\n            </div>\n        `;\n        \n        document.body.appendChild(overlay);\n        \n        // Set up waveform canvas\n        this.waveformCanvas = document.getElementById('recordingWaveform');\n        this.waveformContext = this.waveformCanvas.getContext('2d');\n    }\n    \n    hideRecordingUI() {\n        const overlay = document.getElementById('voiceRecordingOverlay');\n        if (overlay) {\n            overlay.remove();\n        }\n        \n        this.waveformCanvas = null;\n        this.waveformContext = null;\n    }\n    \n    startWaveformAnimation() {\n        if (!this.analyser || !this.waveformContext) {\n            return;\n        }\n        \n        const bufferLength = this.analyser.frequencyBinCount;\n        const dataArray = new Uint8Array(bufferLength);\n        \n        const draw = () => {\n            if (!this.isRecording) {\n                return;\n            }\n            \n            this.animationFrame = requestAnimationFrame(draw);\n            \n            this.analyser.getByteFrequencyData(dataArray);\n            \n            this.waveformContext.fillStyle = '#2a3441';\n            this.waveformContext.fillRect(0, 0, this.waveformCanvas.width, this.waveformCanvas.height);\n            \n            const barWidth = (this.waveformCanvas.width / bufferLength) * 2.5;\n            let barHeight;\n            let x = 0;\n            \n            for (let i = 0; i < bufferLength; i++) {\n                barHeight = (dataArray[i] / 255.0) * this.waveformCanvas.height * 0.8;\n                \n                this.waveformContext.fillStyle = `rgb(0, 136, 204)`;\n                this.waveformContext.fillRect(\n                    x, \n                    this.waveformCanvas.height - barHeight, \n                    barWidth, \n                    barHeight\n                );\n                \n                x += barWidth + 1;\n            }\n        };\n        \n        draw();\n    }\n    \n    stopWaveformAnimation() {\n        if (this.animationFrame) {\n            cancelAnimationFrame(this.animationFrame);\n            this.animationFrame = null;\n        }\n    }\n    \n    startRecordingTimer() {\n        this.recordingTimer = setInterval(() => {\n            const elapsed = Date.now() - this.recordingStartTime;\n            const minutes = Math.floor(elapsed / 60000);\n            const seconds = Math.floor((elapsed % 60000) / 1000);\n            \n            const timeElement = document.getElementById('recordingTime');\n            if (timeElement) {\n                timeElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;\n            }\n            \n            // Auto-stop at max recording time\n            if (elapsed >= this.maxRecordingTime) {\n                this.stopRecording();\n            }\n        }, 100);\n    }\n    \n    stopRecordingTimer() {\n        if (this.recordingTimer) {\n            clearInterval(this.recordingTimer);\n            this.recordingTimer = null;\n        }\n    }\n    \n    async processRecordedAudio() {\n        if (this.recordedChunks.length === 0) {\n            console.warn('No audio data recorded');\n            return;\n        }\n        \n        // Check minimum duration\n        if (this.recordingDuration < 500) {\n            console.warn('Recording too short, discarding');\n            return;\n        }\n        \n        console.log(`🎤 Processing ${this.recordingDuration}ms of audio...`);\n        \n        try {\n            // Create blob from recorded chunks\n            const audioBlob = new Blob(this.recordedChunks, { \n                type: this.selectedMimeType \n            });\n            \n            // Convert to base64 for transmission\n            const audioData = await this.blobToBase64(audioBlob);\n            \n            // Create voice message\n            const voiceMessage = {\n                type: 'voice_message',\n                id: this.generateVoiceMessageId(),\n                data: audioData,\n                duration: this.recordingDuration,\n                mimeType: this.selectedMimeType,\n                timestamp: Date.now()\n            };\n            \n            // Send voice message\n            await this.sendVoiceMessage(voiceMessage);\n            \n            // Display in chat\n            this.displayVoiceMessage(voiceMessage, 'self');\n            \n        } catch (error) {\n            console.error('Failed to process recorded audio:', error);\n            this.showError('Failed to process voice message');\n        }\n    }\n    \n    async blobToBase64(blob) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = () => resolve(reader.result.split(',')[1]);\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n        });\n    }\n    \n    async sendVoiceMessage(voiceMessage) {\n        if (window.cipherWave && window.cipherWave.connectionManager) {\n            await window.cipherWave.connectionManager.sendData(voiceMessage);\n            console.log('🎤 Voice message sent');\n        }\n    }\n    \n    displayVoiceMessage(voiceMessage, sender) {\n        const messagesContainer = document.getElementById('messages');\n        if (!messagesContainer) {\n            return;\n        }\n        \n        const messageElement = document.createElement('div');\n        messageElement.className = `message ${sender === 'self' ? 'message-sent' : 'message-received'}`;\n        \n        const duration = this.formatDuration(voiceMessage.duration);\n        const timestamp = new Date(voiceMessage.timestamp).toLocaleTimeString();\n        \n        messageElement.innerHTML = `\n            <div class=\"voice-message\">\n                <button class=\"voice-message-play\" onclick=\"window.voiceManager.playVoiceMessage('${voiceMessage.id}')\">\n                    <i class=\"fas fa-play\"></i>\n                </button>\n                <div class=\"voice-message-waveform\"></div>\n                <div class=\"voice-message-duration\">${duration}</div>\n            </div>\n            <div class=\"message-time\">${timestamp}</div>\n        `;\n        \n        messagesContainer.appendChild(messageElement);\n        messagesContainer.scrollTop = messagesContainer.scrollHeight;\n        \n        // Store voice message for playback\n        this.voiceMessages.set(voiceMessage.id, voiceMessage);\n    }\n    \n    async playVoiceMessage(messageId) {\n        const voiceMessage = this.voiceMessages.get(messageId);\n        if (!voiceMessage) {\n            console.error('Voice message not found:', messageId);\n            return;\n        }\n        \n        try {\n            // Stop current playback if any\n            if (this.currentlyPlaying) {\n                this.currentlyPlaying.pause();\n                this.currentlyPlaying = null;\n            }\n            \n            // Convert base64 to blob\n            const audioData = atob(voiceMessage.data);\n            const audioArray = new Uint8Array(audioData.length);\n            \n            for (let i = 0; i < audioData.length; i++) {\n                audioArray[i] = audioData.charCodeAt(i);\n            }\n            \n            const audioBlob = new Blob([audioArray], { type: voiceMessage.mimeType });\n            const audioUrl = URL.createObjectURL(audioBlob);\n            \n            // Create and play audio\n            const audio = new Audio(audioUrl);\n            this.currentlyPlaying = audio;\n            this.isPlaying = true;\n            \n            // Update play button\n            const playButton = document.querySelector(`button[onclick=\"window.voiceManager.playVoiceMessage('${messageId}')\"]`);\n            if (playButton) {\n                playButton.innerHTML = '<i class=\"fas fa-pause\"></i>';\n            }\n            \n            audio.onended = () => {\n                this.isPlaying = false;\n                this.currentlyPlaying = null;\n                URL.revokeObjectURL(audioUrl);\n                \n                if (playButton) {\n                    playButton.innerHTML = '<i class=\"fas fa-play\"></i>';\n                }\n            };\n            \n            await audio.play();\n            \n        } catch (error) {\n            console.error('Failed to play voice message:', error);\n            this.showError('Failed to play voice message');\n        }\n    }\n    \n    generateVoiceMessageId() {\n        return `voice_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    formatDuration(milliseconds) {\n        const seconds = Math.floor(milliseconds / 1000);\n        const minutes = Math.floor(seconds / 60);\n        const remainingSeconds = seconds % 60;\n        \n        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n    }\n    \n    showError(message) {\n        if (window.cipherWave && window.cipherWave.uiManager) {\n            window.cipherWave.uiManager.showError(message);\n        } else {\n            console.error(message);\n        }\n    }\n    \n    destroy() {\n        // Stop any ongoing recording\n        if (this.isRecording) {\n            this.stopRecording();\n        }\n        \n        // Stop any playback\n        if (this.currentlyPlaying) {\n            this.currentlyPlaying.pause();\n            this.currentlyPlaying = null;\n        }\n        \n        // Clean up UI\n        if (this.voiceButton) {\n            this.voiceButton.remove();\n        }\n        \n        this.hideRecordingUI();\n        \n        // Remove styles\n        const styles = document.getElementById('voiceManagerStyles');\n        if (styles) {\n            styles.remove();\n        }\n        \n        // Clear voice messages\n        this.voiceMessages.clear();\n        \n        console.log('🗑️ Voice manager destroyed');\n    }\n}\n\n// Make voice manager globally accessible for onclick handlers\nwindow.voiceManager = null;"],"names":["constructor","this","maxFileSize","allowedTypes","images","videos","audio","documents","archives","uploadQueue","activeUploads","Map","compressionSettings","image","quality","maxWidth","maxHeight","video","chunkSize","thumbnailSize","width","height","console","log","setup","setupDragAndDrop","setupFileInput","setupClipboardPaste","createFileUploadUI","dropZone","document","body","addEventListener","e","preventDefault","stopPropagation","classList","add","contains","relatedTarget","remove","files","Array","from","dataTransfer","handleFileSelection","fileInput","createElement","type","multiple","style","display","id","target","appendChild","createFileShareButton","clipboardData","items","filter","item","kind","map","getAsFile","length","chatPanel","getElementById","messageInputGroup","querySelector","fileBtn","className","innerHTML","title","click","insertBefore","lastElementChild","styles","textContent","head","file","validateFile","processFile","size","showError","name","Object","values","flat","some","startsWith","split","fileId","generateFileId","uploadInfo","status","progress","chunks","thumbnail","set","showUploadProgress","generateThumbnail","processedFile","compressFile","splitFileIntoChunks","sendFileMetadata","sendFileChunks","updateUploadProgress","error","message","Promise","resolve","img","Image","onload","canvas","ctx","getContext","calculateThumbnailSize","drawImage","toDataURL","src","URL","createObjectURL","originalWidth","originalHeight","ratio","Math","min","round","totalChunks","ceil","i","start","end","chunk","slice","push","index","data","fileToBase64","reject","reader","FileReader","result","onerror","readAsDataURL","metadata","timestamp","Date","now","window","cipherWave","connectionManager","sendData","chunkMessage","chunkIndex","isLast","setTimeout","messagesContainer","progressElement","formatFileSize","scrollTop","scrollHeight","progressFill","parentElement","borderColor","details","color","random","toString","substr","bytes","floor","parseFloat","pow","toFixed","uiManager","destroy","clear","voiceManager","isRecording","mediaRecorder","audioContext","analyser","microphone","recordedChunks","recordingStartTime","recordingDuration","maxRecordingTime","recordingTimer","waveformCanvas","waveformContext","animationFrame","supportedMimeTypes","selectedMimeType","voiceMessages","voiceButton","recordingIndicator","waveformContainer","currentlyPlaying","isPlaying","microphoneAccess","compressionOptions","mimeType","audioBitsPerSecond","init","requestMicrophoneAccess","detectSupportedMimeType","createVoiceUI","stream","navigator","mediaDevices","getUserMedia","echoCancellation","noiseSuppression","autoGainControl","getTracks","forEach","track","stop","Error","MediaRecorder","isTypeSupported","startRecording","stopRecording","addVoiceStyles","AudioContext","webkitAudioContext","createAnalyser","createMediaStreamSource","connect","fftSize","ondataavailable","event","onstop","processRecordedAudio","showRecordingUI","startWaveformAnimation","startRecordingTimer","state","close","hideRecordingUI","stopWaveformAnimation","stopRecordingTimer","overlay","bufferLength","frequencyBinCount","dataArray","Uint8Array","draw","requestAnimationFrame","getByteFrequencyData","fillStyle","fillRect","barWidth","barHeight","x","cancelAnimationFrame","setInterval","elapsed","minutes","seconds","timeElement","padStart","clearInterval","warn","audioBlob","Blob","audioData","blobToBase64","voiceMessage","generateVoiceMessageId","duration","sendVoiceMessage","displayVoiceMessage","blob","sender","messageElement","formatDuration","toLocaleTimeString","playVoiceMessage","messageId","get","pause","atob","audioArray","charCodeAt","audioUrl","Audio","playButton","onended","revokeObjectURL","play","milliseconds"],"mappings":"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"}