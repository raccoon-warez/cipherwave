{"version":3,"file":"chunk-DeIA6xm2.js","sources":["../../node_modules/simple-peer/index.js"],"sourcesContent":["/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nconst debug = require('debug')('simple-peer')\nconst getBrowserRTC = require('get-browser-rtc')\nconst randombytes = require('randombytes')\nconst stream = require('readable-stream')\nconst queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported\nconst errCode = require('err-code')\nconst { Buffer } = require('buffer')\n\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\n\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction filterTrickle (sdp) {\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\n}\n\nfunction warn (message) {\n  console.warn(message)\n}\n\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */\nclass Peer extends stream.Duplex {\n  constructor (opts) {\n    opts = Object.assign({\n      allowHalfOpen: false\n    }, opts)\n\n    super(opts)\n\n    this._id = randombytes(4).toString('hex').slice(0, 7)\n    this._debug('new peer %o', opts)\n\n    this.channelName = opts.initiator\n      ? opts.channelName || randombytes(20).toString('hex')\n      : null\n\n    this.initiator = opts.initiator || false\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\n    this.channelNegotiated = this.channelConfig.negotiated\n    this.config = Object.assign({}, Peer.config, opts.config)\n    this.offerOptions = opts.offerOptions || {}\n    this.answerOptions = opts.answerOptions || {}\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old \"stream\" option\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\n\n    this.destroyed = false\n    this.destroying = false\n    this._connected = false\n\n    this.remoteAddress = undefined\n    this.remoteFamily = undefined\n    this.remotePort = undefined\n    this.localAddress = undefined\n    this.localFamily = undefined\n    this.localPort = undefined\n\n    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')\n      ? opts.wrtc\n      : getBrowserRTC()\n\n    if (!this._wrtc) {\n      if (typeof window === 'undefined') {\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\n      } else {\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\n      }\n    }\n\n    this._pcReady = false\n    this._channelReady = false\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n    this._channel = null\n    this._pendingCandidates = []\n\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\n    this._firstNegotiation = true\n    this._batchedNegotiation = false // batch synchronous negotiations\n    this._queuedNegotiation = false // is there a queued negotiation request?\n    this._sendersAwaitingStable = []\n    this._senderMap = new Map()\n    this._closingInterval = null\n\n    this._remoteTracks = []\n    this._remoteStreams = []\n\n    this._chunk = null\n    this._cb = null\n    this._interval = null\n\n    try {\n      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)\n    } catch (err) {\n      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\n      return\n    }\n\n    // We prefer feature detection whenever possible, but sometimes that's not\n    // possible for certain implementations.\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\n\n    this._pc.oniceconnectionstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onicegatheringstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onconnectionstatechange = () => {\n      this._onConnectionStateChange()\n    }\n    this._pc.onsignalingstatechange = () => {\n      this._onSignalingStateChange()\n    }\n    this._pc.onicecandidate = event => {\n      this._onIceCandidate(event)\n    }\n\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\n    if (typeof this._pc.peerIdentity === 'object') {\n      this._pc.peerIdentity.catch(err => {\n        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\n      })\n    }\n\n    // Other spec events, unused by this implementation:\n    // - onconnectionstatechange\n    // - onicecandidateerror\n    // - onfingerprintfailure\n    // - onnegotiationneeded\n\n    if (this.initiator || this.channelNegotiated) {\n      this._setupData({\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n      })\n    } else {\n      this._pc.ondatachannel = event => {\n        this._setupData(event)\n      }\n    }\n\n    if (this.streams) {\n      this.streams.forEach(stream => {\n        this.addStream(stream)\n      })\n    }\n    this._pc.ontrack = event => {\n      this._onTrack(event)\n    }\n\n    this._debug('initial negotiation')\n    this._needsNegotiation()\n\n    this._onFinishBound = () => {\n      this._onFinish()\n    }\n    this.once('finish', this._onFinishBound)\n  }\n\n  get bufferSize () {\n    return (this._channel && this._channel.bufferedAmount) || 0\n  }\n\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n  get connected () {\n    return (this._connected && this._channel.readyState === 'open')\n  }\n\n  address () {\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\n  }\n\n  signal (data) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data)\n      } catch (err) {\n        data = {}\n      }\n    }\n    this._debug('signal()')\n\n    if (data.renegotiate && this.initiator) {\n      this._debug('got request to renegotiate')\n      this._needsNegotiation()\n    }\n    if (data.transceiverRequest && this.initiator) {\n      this._debug('got request for transceiver')\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\n    }\n    if (data.candidate) {\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n        this._addIceCandidate(data.candidate)\n      } else {\n        this._pendingCandidates.push(data.candidate)\n      }\n    }\n    if (data.sdp) {\n      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))\n        .then(() => {\n          if (this.destroyed) return\n\n          this._pendingCandidates.forEach(candidate => {\n            this._addIceCandidate(candidate)\n          })\n          this._pendingCandidates = []\n\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\n        })\n        .catch(err => {\n          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\n        })\n    }\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\n    }\n  }\n\n  _addIceCandidate (candidate) {\n    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)\n    this._pc.addIceCandidate(iceCandidateObj)\n      .catch(err => {\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\n          warn('Ignoring unsupported ICE candidate.')\n        } else {\n          this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\n        }\n      })\n  }\n\n  /**\n   * Send text/binary data to the remote peer.\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\n   */\n  send (chunk) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\n    this._channel.send(chunk)\n  }\n\n  /**\n   * Add a Transceiver to the connection.\n   * @param {String} kind\n   * @param {Object} init\n   */\n  addTransceiver (kind, init) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('addTransceiver()')\n\n    if (this.initiator) {\n      try {\n        this._pc.addTransceiver(kind, init)\n        this._needsNegotiation()\n      } catch (err) {\n        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))\n      }\n    } else {\n      this.emit('signal', { // request initiator to renegotiate\n        type: 'transceiverRequest',\n        transceiverRequest: { kind, init }\n      })\n    }\n  }\n\n  /**\n   * Add a MediaStream to the connection.\n   * @param {MediaStream} stream\n   */\n  addStream (stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('addStream()')\n\n    stream.getTracks().forEach(track => {\n      this.addTrack(track, stream)\n    })\n  }\n\n  /**\n   * Add a MediaStreamTrack to the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  addTrack (track, stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('addTrack()')\n\n    const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n    let sender = submap.get(stream)\n    if (!sender) {\n      sender = this._pc.addTrack(track, stream)\n      submap.set(stream, sender)\n      this._senderMap.set(track, submap)\n      this._needsNegotiation()\n    } else if (sender.removed) {\n      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')\n    } else {\n      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')\n    }\n  }\n\n  /**\n   * Replace a MediaStreamTrack by another in the connection.\n   * @param {MediaStreamTrack} oldTrack\n   * @param {MediaStreamTrack} newTrack\n   * @param {MediaStream} stream\n   */\n  replaceTrack (oldTrack, newTrack, stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('replaceTrack()')\n\n    const submap = this._senderMap.get(oldTrack)\n    const sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')\n    }\n    if (newTrack) this._senderMap.set(newTrack, submap)\n\n    if (sender.replaceTrack != null) {\n      sender.replaceTrack(newTrack)\n    } else {\n      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))\n    }\n  }\n\n  /**\n   * Remove a MediaStreamTrack from the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  removeTrack (track, stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('removeSender()')\n\n    const submap = this._senderMap.get(track)\n    const sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')\n    }\n    try {\n      sender.removed = true\n      this._pc.removeTrack(sender)\n    } catch (err) {\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\n        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n      } else {\n        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))\n      }\n    }\n    this._needsNegotiation()\n  }\n\n  /**\n   * Remove a MediaStream from the connection.\n   * @param {MediaStream} stream\n   */\n  removeStream (stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('removeSenders()')\n\n    stream.getTracks().forEach(track => {\n      this.removeTrack(track, stream)\n    })\n  }\n\n  _needsNegotiation () {\n    this._debug('_needsNegotiation')\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\n    this._batchedNegotiation = true\n    queueMicrotask(() => {\n      this._batchedNegotiation = false\n      if (this.initiator || !this._firstNegotiation) {\n        this._debug('starting batched negotiation')\n        this.negotiate()\n      } else {\n        this._debug('non-initiator initial negotiation request discarded')\n      }\n      this._firstNegotiation = false\n    })\n  }\n\n  negotiate () {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\n\n    if (this.initiator) {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('start negotiation')\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\n          this._createOffer()\n        }, 0)\n      }\n    } else {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('requesting negotiation from initiator')\n        this.emit('signal', { // request initiator to renegotiate\n          type: 'renegotiate',\n          renegotiate: true\n        })\n      }\n    }\n    this._isNegotiating = true\n  }\n\n  // TODO: Delete this method once readable-stream is updated to contain a default\n  // implementation of destroy() that automatically calls _destroy()\n  // See: https://github.com/nodejs/readable-stream/issues/283\n  destroy (err) {\n    this._destroy(err, () => {})\n  }\n\n  _destroy (err, cb) {\n    if (this.destroyed || this.destroying) return\n    this.destroying = true\n\n    this._debug('destroying (error: %s)', err && (err.message || err))\n\n    queueMicrotask(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\n      this.destroyed = true\n      this.destroying = false\n\n      this._debug('destroy (error: %s)', err && (err.message || err))\n\n      this.readable = this.writable = false\n\n      if (!this._readableState.ended) this.push(null)\n      if (!this._writableState.finished) this.end()\n\n      this._connected = false\n      this._pcReady = false\n      this._channelReady = false\n      this._remoteTracks = null\n      this._remoteStreams = null\n      this._senderMap = null\n\n      clearInterval(this._closingInterval)\n      this._closingInterval = null\n\n      clearInterval(this._interval)\n      this._interval = null\n      this._chunk = null\n      this._cb = null\n\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\n      this._onFinishBound = null\n\n      if (this._channel) {\n        try {\n          this._channel.close()\n        } catch (err) {}\n\n        // allow events concurrent with destruction to be handled\n        this._channel.onmessage = null\n        this._channel.onopen = null\n        this._channel.onclose = null\n        this._channel.onerror = null\n      }\n      if (this._pc) {\n        try {\n          this._pc.close()\n        } catch (err) {}\n\n        // allow events concurrent with destruction to be handled\n        this._pc.oniceconnectionstatechange = null\n        this._pc.onicegatheringstatechange = null\n        this._pc.onsignalingstatechange = null\n        this._pc.onicecandidate = null\n        this._pc.ontrack = null\n        this._pc.ondatachannel = null\n      }\n      this._pc = null\n      this._channel = null\n\n      if (err) this.emit('error', err)\n      this.emit('close')\n      cb()\n    })\n  }\n\n  _setupData (event) {\n    if (!event.channel) {\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n      // which is invalid behavior. Handle it gracefully.\n      // See: https://github.com/feross/simple-peer/issues/163\n      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\n    }\n\n    this._channel = event.channel\n    this._channel.binaryType = 'arraybuffer'\n\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\n    }\n\n    this.channelName = this._channel.label\n\n    this._channel.onmessage = event => {\n      this._onChannelMessage(event)\n    }\n    this._channel.onbufferedamountlow = () => {\n      this._onChannelBufferedAmountLow()\n    }\n    this._channel.onopen = () => {\n      this._onChannelOpen()\n    }\n    this._channel.onclose = () => {\n      this._onChannelClose()\n    }\n    this._channel.onerror = event => {\n      const err = event.error instanceof Error\n        ? event.error\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\n      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n    }\n\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    let isClosing = false\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\n      if (this._channel && this._channel.readyState === 'closing') {\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n        isClosing = true\n      } else {\n        isClosing = false\n      }\n    }, CHANNEL_CLOSING_TIMEOUT)\n  }\n\n  _read () {}\n\n  _write (chunk, encoding, cb) {\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\n\n    if (this._connected) {\n      try {\n        this.send(chunk)\n      } catch (err) {\n        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n      }\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n        this._cb = cb\n      } else {\n        cb(null)\n      }\n    } else {\n      this._debug('write before connect')\n      this._chunk = chunk\n      this._cb = cb\n    }\n  }\n\n  // When stream finishes writing, close socket. Half open connections are not\n  // supported.\n  _onFinish () {\n    if (this.destroyed) return\n\n    // Wait a bit before destroying so the socket flushes.\n    // TODO: is there a more reliable way to accomplish this?\n    const destroySoon = () => {\n      setTimeout(() => this.destroy(), 1000)\n    }\n\n    if (this._connected) {\n      destroySoon()\n    } else {\n      this.once('connect', destroySoon)\n    }\n  }\n\n  _startIceCompleteTimeout () {\n    if (this.destroyed) return\n    if (this._iceCompleteTimer) return\n    this._debug('started iceComplete timeout')\n    this._iceCompleteTimer = setTimeout(() => {\n      if (!this._iceComplete) {\n        this._iceComplete = true\n        this._debug('iceComplete timeout completed')\n        this.emit('iceTimeout')\n        this.emit('_iceComplete')\n      }\n    }, this.iceCompleteTimeout)\n  }\n\n  _createOffer () {\n    if (this.destroyed) return\n\n    this._pc.createOffer(this.offerOptions)\n      .then(offer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\n        offer.sdp = this.sdpTransform(offer.sdp)\n\n        const sendOffer = () => {\n          if (this.destroyed) return\n          const signal = this._pc.localDescription || offer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n        }\n\n        const onSuccess = () => {\n          this._debug('createOffer success')\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendOffer()\n          else this.once('_iceComplete', sendOffer) // wait for candidates\n        }\n\n        const onError = err => {\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(offer)\n          .then(onSuccess)\n          .catch(onError)\n      })\n      .catch(err => {\n        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))\n      })\n  }\n\n  _requestMissingTransceivers () {\n    if (this._pc.getTransceivers) {\n      this._pc.getTransceivers().forEach(transceiver => {\n        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n          this.addTransceiver(transceiver.sender.track.kind)\n        }\n      })\n    }\n  }\n\n  _createAnswer () {\n    if (this.destroyed) return\n\n    this._pc.createAnswer(this.answerOptions)\n      .then(answer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\n        answer.sdp = this.sdpTransform(answer.sdp)\n\n        const sendAnswer = () => {\n          if (this.destroyed) return\n          const signal = this._pc.localDescription || answer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n          if (!this.initiator) this._requestMissingTransceivers()\n        }\n\n        const onSuccess = () => {\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendAnswer()\n          else this.once('_iceComplete', sendAnswer)\n        }\n\n        const onError = err => {\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(answer)\n          .then(onSuccess)\n          .catch(onError)\n      })\n      .catch(err => {\n        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))\n      })\n  }\n\n  _onConnectionStateChange () {\n    if (this.destroyed) return\n    if (this._pc.connectionState === 'failed') {\n      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\n    }\n  }\n\n  _onIceStateChange () {\n    if (this.destroyed) return\n    const iceConnectionState = this._pc.iceConnectionState\n    const iceGatheringState = this._pc.iceGatheringState\n\n    this._debug(\n      'iceStateChange (connection: %s) (gathering: %s)',\n      iceConnectionState,\n      iceGatheringState\n    )\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\n\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n      this._pcReady = true\n      this._maybeReady()\n    }\n    if (iceConnectionState === 'failed') {\n      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\n    }\n    if (iceConnectionState === 'closed') {\n      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\n    }\n  }\n\n  getStats (cb) {\n    // statreports can come with a value array instead of properties\n    const flattenValues = report => {\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\n        report.values.forEach(value => {\n          Object.assign(report, value)\n        })\n      }\n      return report\n    }\n\n    // Promise-based getStats() (standard)\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n      this._pc.getStats()\n        .then(res => {\n          const reports = []\n          res.forEach(report => {\n            reports.push(flattenValues(report))\n          })\n          cb(null, reports)\n        }, err => cb(err))\n\n    // Single-parameter callback-based getStats() (non-standard)\n    } else if (this._pc.getStats.length > 0) {\n      this._pc.getStats(res => {\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n        if (this.destroyed) return\n\n        const reports = []\n        res.result().forEach(result => {\n          const report = {}\n          result.names().forEach(name => {\n            report[name] = result.stat(name)\n          })\n          report.id = result.id\n          report.type = result.type\n          report.timestamp = result.timestamp\n          reports.push(flattenValues(report))\n        })\n        cb(null, reports)\n      }, err => cb(err))\n\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\n    // getStats() they implement.\n    } else {\n      cb(null, [])\n    }\n  }\n\n  _maybeReady () {\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\n\n    this._connecting = true\n\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n    const findCandidatePair = () => {\n      if (this.destroyed) return\n\n      this.getStats((err, items) => {\n        if (this.destroyed) return\n\n        // Treat getStats error as non-fatal. It's not essential.\n        if (err) items = []\n\n        const remoteCandidates = {}\n        const localCandidates = {}\n        const candidatePairs = {}\n        let foundSelectedCandidatePair = false\n\n        items.forEach(item => {\n          // TODO: Once all browsers support the hyphenated stats report types, remove\n          // the non-hypenated ones\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\n            remoteCandidates[item.id] = item\n          }\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\n            localCandidates[item.id] = item\n          }\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\n            candidatePairs[item.id] = item\n          }\n        })\n\n        const setSelectedCandidatePair = selectedCandidatePair => {\n          foundSelectedCandidatePair = true\n\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\n\n          if (local && (local.ip || local.address)) {\n            // Spec\n            this.localAddress = local.ip || local.address\n            this.localPort = Number(local.port)\n          } else if (local && local.ipAddress) {\n            // Firefox\n            this.localAddress = local.ipAddress\n            this.localPort = Number(local.portNumber)\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            local = selectedCandidatePair.googLocalAddress.split(':')\n            this.localAddress = local[0]\n            this.localPort = Number(local[1])\n          }\n          if (this.localAddress) {\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\n          }\n\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\n\n          if (remote && (remote.ip || remote.address)) {\n            // Spec\n            this.remoteAddress = remote.ip || remote.address\n            this.remotePort = Number(remote.port)\n          } else if (remote && remote.ipAddress) {\n            // Firefox\n            this.remoteAddress = remote.ipAddress\n            this.remotePort = Number(remote.portNumber)\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\n            this.remoteAddress = remote[0]\n            this.remotePort = Number(remote[1])\n          }\n          if (this.remoteAddress) {\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\n          }\n\n          this._debug(\n            'connect local: %s:%s remote: %s:%s',\n            this.localAddress,\n            this.localPort,\n            this.remoteAddress,\n            this.remotePort\n          )\n        }\n\n        items.forEach(item => {\n          // Spec-compliant\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\n          }\n\n          // Old implementations\n          if (\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\n          ) {\n            setSelectedCandidatePair(item)\n          }\n        })\n\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n        // But wait until at least 1 candidate pair is available\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n          setTimeout(findCandidatePair, 100)\n          return\n        } else {\n          this._connecting = false\n          this._connected = true\n        }\n\n        if (this._chunk) {\n          try {\n            this.send(this._chunk)\n          } catch (err) {\n            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n          }\n          this._chunk = null\n          this._debug('sent chunk from \"write before connect\"')\n\n          const cb = this._cb\n          this._cb = null\n          cb(null)\n        }\n\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n        // fallback to using setInterval to implement backpressure.\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\n          this._interval = setInterval(() => this._onInterval(), 150)\n          if (this._interval.unref) this._interval.unref()\n        }\n\n        this._debug('connect')\n        this.emit('connect')\n      })\n    }\n    findCandidatePair()\n  }\n\n  _onInterval () {\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n      return\n    }\n    this._onChannelBufferedAmountLow()\n  }\n\n  _onSignalingStateChange () {\n    if (this.destroyed) return\n\n    if (this._pc.signalingState === 'stable') {\n      this._isNegotiating = false\n\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\n      this._sendersAwaitingStable.forEach(sender => {\n        this._pc.removeTrack(sender)\n        this._queuedNegotiation = true\n      })\n      this._sendersAwaitingStable = []\n\n      if (this._queuedNegotiation) {\n        this._debug('flushing negotiation queue')\n        this._queuedNegotiation = false\n        this._needsNegotiation() // negotiate again\n      } else {\n        this._debug('negotiated')\n        this.emit('negotiated')\n      }\n    }\n\n    this._debug('signalingStateChange %s', this._pc.signalingState)\n    this.emit('signalingStateChange', this._pc.signalingState)\n  }\n\n  _onIceCandidate (event) {\n    if (this.destroyed) return\n    if (event.candidate && this.trickle) {\n      this.emit('signal', {\n        type: 'candidate',\n        candidate: {\n          candidate: event.candidate.candidate,\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          sdpMid: event.candidate.sdpMid\n        }\n      })\n    } else if (!event.candidate && !this._iceComplete) {\n      this._iceComplete = true\n      this.emit('_iceComplete')\n    }\n    // as soon as we've received one valid candidate start timeout\n    if (event.candidate) {\n      this._startIceCompleteTimeout()\n    }\n  }\n\n  _onChannelMessage (event) {\n    if (this.destroyed) return\n    let data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    this.push(data)\n  }\n\n  _onChannelBufferedAmountLow () {\n    if (this.destroyed || !this._cb) return\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n    const cb = this._cb\n    this._cb = null\n    cb(null)\n  }\n\n  _onChannelOpen () {\n    if (this._connected || this.destroyed) return\n    this._debug('on channel open')\n    this._channelReady = true\n    this._maybeReady()\n  }\n\n  _onChannelClose () {\n    if (this.destroyed) return\n    this._debug('on channel close')\n    this.destroy()\n  }\n\n  _onTrack (event) {\n    if (this.destroyed) return\n\n    event.streams.forEach(eventStream => {\n      this._debug('on track')\n      this.emit('track', event.track, eventStream)\n\n      this._remoteTracks.push({\n        track: event.track,\n        stream: eventStream\n      })\n\n      if (this._remoteStreams.some(remoteStream => {\n        return remoteStream.id === eventStream.id\n      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream\n\n      this._remoteStreams.push(eventStream)\n      queueMicrotask(() => {\n        this._debug('on stream')\n        this.emit('stream', eventStream) // ensure all tracks have been added\n      })\n    })\n  }\n\n  _debug () {\n    const args = [].slice.call(arguments)\n    args[0] = '[' + this._id + '] ' + args[0]\n    debug.apply(null, args)\n  }\n}\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC()\n\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */\nPeer.config = {\n  iceServers: [\n    {\n      urls: [\n        'stun:stun.l.google.com:19302',\n        'stun:global.stun.twilio.com:3478'\n      ]\n    }\n  ],\n  sdpSemantics: 'unified-plan'\n}\n\nPeer.channelConfig = {}\n\nmodule.exports = Peer\n"],"names":["debug","require$$0","getBrowserRTC","require$$1","randombytes","require$$2","stream","require$$3","queueMicrotask","require$$4","errCode","require$$5","Buffer","require$$6","MAX_BUFFERED_AMOUNT","filterTrickle","sdp","replace","Peer","Duplex","constructor","opts","super","Object","assign","allowHalfOpen","this","_id","toString","slice","_debug","channelName","initiator","channelConfig","channelNegotiated","negotiated","config","offerOptions","answerOptions","sdpTransform","streams","trickle","allowHalfTrickle","iceCompleteTimeout","destroyed","destroying","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","_wrtc","wrtc","window","Error","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_channel","_pendingCandidates","_isNegotiating","_firstNegotiation","_batchedNegotiation","_queuedNegotiation","_sendersAwaitingStable","_senderMap","Map","_closingInterval","_remoteTracks","_remoteStreams","_chunk","_cb","_interval","_pc","RTCPeerConnection","err","destroy","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","event","_onIceCandidate","peerIdentity","catch","_setupData","channel","createDataChannel","ondatachannel","forEach","addStream","ontrack","_onTrack","_needsNegotiation","_onFinishBound","_onFinish","once","bufferSize","bufferedAmount","connected","readyState","address","port","family","signal","data","JSON","parse","renegotiate","transceiverRequest","addTransceiver","kind","init","candidate","remoteDescription","type","_addIceCandidate","push","setRemoteDescription","RTCSessionDescription","then","_createAnswer","iceCandidateObj","RTCIceCandidate","addIceCandidate","message","endsWith","console","warn","send","chunk","emit","getTracks","track","addTrack","submap","get","sender","removed","set","replaceTrack","oldTrack","newTrack","removeTrack","name","removeStream","negotiate","setTimeout","_createOffer","_destroy","cb","readable","writable","_readableState","ended","_writableState","finished","end","clearInterval","removeListener","close","onmessage","onopen","onclose","onerror","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","error","filename","lineno","colno","isClosing","setInterval","_read","_write","encoding","destroySoon","_startIceCompleteTimeout","createOffer","offer","sendOffer","localDescription","setLocalDescription","_requestMissingTransceivers","getTransceivers","transceiver","mid","requested","createAnswer","answer","sendAnswer","connectionState","iceConnectionState","iceGatheringState","_maybeReady","getStats","flattenValues","report","prototype","call","values","value","length","res","reports","result","names","stat","id","timestamp","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","item","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","Number","ipAddress","portNumber","googLocalAddress","split","includes","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","keys","_onInterval","unref","signalingState","sdpMLineIndex","sdpMid","ArrayBuffer","from","eventStream","some","remoteStream","args","arguments","apply","WEBRTC_SUPPORT","iceServers","urls","sdpSemantics"],"mappings":"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","x_google_ignoreList":[0]}