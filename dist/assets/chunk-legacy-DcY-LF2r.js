System.register(["./chunk-legacy-DzyBHhKg.js","./chunk-legacy-_OE_0di3.js"],function(e,t){"use strict";var n,s;return{setters:[e=>{n=e.s},e=>{s=e.P}],execute:function(){e("S",class{constructor(){this.isInitialized=!1,this.identityKeys=null,this.ephemeralKeys=null,this.sessionKey=null,this.peerPublicKey=null,this.currentCipher="chacha20-poly1305",this.supportedCiphers={"chacha20-poly1305":{keyLength:32,nonceLength:12,encrypt:this.encryptChaCha20Poly1305.bind(this),decrypt:this.decryptChaCha20Poly1305.bind(this)},aes:{keyLength:32,nonceLength:12,encrypt:this.encryptAES256GCM.bind(this),decrypt:this.decryptAES256GCM.bind(this)}},this.metrics={encryptionTime:0,decryptionTime:0,keyGenerationTime:0}}async initialize(){console.log("🔐 Initializing security manager with libsodium...");const e=performance.now();try{await n.ready,this.identityKeys=n.crypto_sign_keypair(),this.ephemeralKeys=n.crypto_box_keypair(),this.isInitialized=!0,this.metrics.keyGenerationTime=performance.now()-e,console.log(`✅ Security manager initialized (${this.metrics.keyGenerationTime.toFixed(2)}ms)`)}catch(t){throw console.error("❌ Failed to initialize security manager:",t),new Error(`Security initialization failed: ${t.message}`)}}async setCipher(e){if(!this.supportedCiphers[e])throw new Error(`Unsupported cipher: ${e}`);this.currentCipher=e,console.log(`🔒 Switched to cipher: ${e}`)}async performKeyExchange(e){if(!this.isInitialized)throw new Error("Security manager not initialized");try{const t="string"==typeof e?n.from_hex(e):e,s=n.crypto_box_beforenm(t,this.ephemeralKeys.privateKey);return this.sessionKey=n.crypto_kdf_derive_from_key(32,1,"CipherWv",s),this.peerPublicKey=t,console.log("🤝 Key exchange completed"),n.to_hex(this.ephemeralKeys.publicKey)}catch(t){throw console.error("Key exchange failed:",t),new Error(`Key exchange failed: ${t.message}`)}}async encryptMessage(e){if(!this.sessionKey)throw new Error("No session key available");const t=performance.now();try{const s=this.supportedCiphers[this.currentCipher],i=await s.encrypt(e);return this.metrics.encryptionTime=performance.now()-t,{ciphertext:n.to_base64(i.ciphertext),nonce:n.to_base64(i.nonce),cipher:this.currentCipher,timestamp:Date.now()}}catch(s){throw console.error("Encryption failed:",s),new Error(`Encryption failed: ${s.message}`)}}async decryptMessage(e){if(!this.sessionKey)throw new Error("No session key available");const t=performance.now();try{const s=this.supportedCiphers[e.cipher];if(!s)throw new Error(`Unsupported cipher: ${e.cipher}`);const i=n.from_base64(e.ciphertext),o=n.from_base64(e.nonce),r=await s.decrypt(i,o);return this.metrics.decryptionTime=performance.now()-t,{text:n.to_string(r),timestamp:e.timestamp,cipher:e.cipher}}catch(s){throw console.error("Decryption failed:",s),new Error(`Decryption failed: ${s.message}`)}}async encryptChaCha20Poly1305(e){const t=n.randombytes_buf(12),s=n.from_string(e);return{ciphertext:n.crypto_secretbox_easy(s,t,this.sessionKey),nonce:t}}async decryptChaCha20Poly1305(e,t){return n.crypto_secretbox_open_easy(e,t,this.sessionKey)}async encryptAES256GCM(e){const t=n.randombytes_buf(12),s=n.from_string(e);return{ciphertext:n.crypto_aead_aes256gcm_encrypt(s,null,null,t,this.sessionKey),nonce:t}}async decryptAES256GCM(e,t){return n.crypto_aead_aes256gcm_decrypt(null,e,null,t,this.sessionKey)}generateNonce(e=12){return n.randombytes_buf(e)}generateRoomId(){return n.to_hex(n.randombytes_buf(16)).toUpperCase()}getPublicKey(){if(!this.ephemeralKeys)throw new Error("Keys not generated");return n.to_hex(this.ephemeralKeys.publicKey)}getIdentityPublicKey(){if(!this.identityKeys)throw new Error("Identity keys not generated");return n.to_hex(this.identityKeys.publicKey)}signData(e){if(!this.identityKeys)throw new Error("Identity keys not available");const t="string"==typeof e?n.from_string(e):e;return n.crypto_sign_detached(t,this.identityKeys.privateKey)}verifySignature(e,t,s){const i="string"==typeof e?n.from_string(e):e,o="string"==typeof t?n.from_hex(t):t,r="string"==typeof s?n.from_hex(s):s;return n.crypto_sign_verify_detached(o,i,r)}getMetrics(){return{...this.metrics}}destroy(){this.sessionKey&&(n.memzero(this.sessionKey),this.sessionKey=null),this.ephemeralKeys&&(n.memzero(this.ephemeralKeys.privateKey),this.ephemeralKeys=null),this.identityKeys&&(n.memzero(this.identityKeys.privateKey),this.identityKeys=null),this.peerPublicKey=null,this.isInitialized=!1,console.log("🗑️ Security manager destroyed")}}),e("M",class{constructor(e){this.securityManager=e,this.eventHandlers=new Map,this.messageQueue=[],this.pendingMessages=new Map,this.messageCounter=0,this.deliveryTimeout=3e4,this.retryAttempts=3,this.metrics={messagesSent:0,messagesReceived:0,averageEncryptionTime:0,averageDecryptionTime:0},console.log("💬 Message manager initialized")}on(e,t){this.eventHandlers.has(e)||this.eventHandlers.set(e,[]),this.eventHandlers.get(e).push(t)}emit(e,t){const n=this.eventHandlers.get(e);n&&n.forEach(n=>{try{n(t)}catch(s){console.error(`Error in ${e} handler:`,s)}})}async encryptMessage(e,t={}){if(!this.securityManager.isInitialized)throw new Error("Security manager not initialized");const n=performance.now();try{const s=this.generateMessageId(),i=Date.now(),o={id:s,text:e,timestamp:i,type:t.type||"text",metadata:t.metadata||{}},r={id:s,type:"encrypted_message",payload:await this.securityManager.encryptMessage(JSON.stringify(o)),timestamp:i,requiresAck:!1!==t.requiresAck},a=performance.now()-n;return this.updateEncryptionMetrics(a),r.requiresAck&&this.trackMessageDelivery(s,r),this.metrics.messagesSent++,console.log(`🔒 Message encrypted (${a.toFixed(2)}ms)`),r}catch(s){throw console.error("Message encryption failed:",s),new Error(`Failed to encrypt message: ${s.message}`)}}async decryptMessage(e){if(!this.securityManager.isInitialized)throw new Error("Security manager not initialized");const t=performance.now();try{if("encrypted_message"===e.type){const n=await this.securityManager.decryptMessage(e.payload),s=JSON.parse(n.text);e.requiresAck&&this.sendAcknowledgment(e.id);const i=performance.now()-t;this.updateDecryptionMetrics(i),this.metrics.messagesReceived++;const o={id:s.id,text:s.text,timestamp:s.timestamp,type:s.type,metadata:s.metadata||{},decrypted:!0,decryptionTime:i};return this.emit("messageDecrypted",o),console.log(`🔓 Message decrypted (${i.toFixed(2)}ms)`),o}return"acknowledgment"===e.type?(this.handleAcknowledgment(e.messageId),null):"ping"===e.type?(this.handlePing(e),null):(console.warn("Unknown message type:",e.type),null)}catch(n){throw console.error("Message decryption failed:",n),e.requiresAck&&this.sendErrorAcknowledgment(e.id,n.message),new Error(`Failed to decrypt message: ${n.message}`)}}generateMessageId(){return this.messageCounter++,`msg_${Date.now()}_${this.messageCounter}_${Math.random().toString(36).substr(2,9)}`}trackMessageDelivery(e,t){const n={message:t,sentAt:Date.now(),attempts:0,maxAttempts:this.retryAttempts};this.pendingMessages.set(e,n),setTimeout(()=>{this.pendingMessages.has(e)&&this.handleDeliveryTimeout(e)},this.deliveryTimeout)}sendAcknowledgment(e){const t={type:"acknowledgment",messageId:e,timestamp:Date.now(),status:"delivered"};this.emit("sendAcknowledgment",t)}sendErrorAcknowledgment(e,t){const n={type:"acknowledgment",messageId:e,timestamp:Date.now(),status:"error",error:t};this.emit("sendAcknowledgment",n)}handleAcknowledgment(e){if(this.pendingMessages.has(e)){const t=this.pendingMessages.get(e);this.pendingMessages.delete(e),console.log(`✅ Message ${e} delivered`),this.emit("messageDelivered",{messageId:e,deliveryTime:Date.now()-t.sentAt})}}handleDeliveryTimeout(e){const t=this.pendingMessages.get(e);t&&(t.attempts++,t.attempts<t.maxAttempts?(console.log(`🔄 Retrying message ${e} (attempt ${t.attempts})`),this.emit("retryMessage",t.message),setTimeout(()=>{this.pendingMessages.has(e)&&this.handleDeliveryTimeout(e)},this.deliveryTimeout)):(console.error(`❌ Message ${e} delivery failed after ${t.attempts} attempts`),this.pendingMessages.delete(e),this.emit("messageDeliveryFailed",{messageId:e,attempts:t.attempts,message:t.message})))}handlePing(e){const t={type:"pong",originalTimestamp:e.timestamp,timestamp:Date.now()};this.emit("sendPong",t)}updateEncryptionMetrics(e){0===this.metrics.messagesSent?this.metrics.averageEncryptionTime=e:this.metrics.averageEncryptionTime=(this.metrics.averageEncryptionTime*(this.metrics.messagesSent-1)+e)/this.metrics.messagesSent}updateDecryptionMetrics(e){0===this.metrics.messagesReceived?this.metrics.averageDecryptionTime=e:this.metrics.averageDecryptionTime=(this.metrics.averageDecryptionTime*(this.metrics.messagesReceived-1)+e)/this.metrics.messagesReceived}getPendingMessagesCount(){return this.pendingMessages.size}getMetrics(){return{...this.metrics,pendingMessages:this.getPendingMessagesCount()}}clearPendingMessages(){this.pendingMessages.clear(),console.log("🗑️ Cleared all pending messages")}destroy(){this.clearPendingMessages(),this.messageQueue=[],this.eventHandlers.clear(),this.messageCounter=0,console.log("🗑️ Message manager destroyed")}}),e("C",class{constructor(e={}){this.configuration={initiator:!1,trickle:!0,...e},this.peer=null,this.isConnected=!1,this.isConnecting=!1,this.connectionState="new",this.eventHandlers=new Map,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.reconnectDelay=1e3,this.connectionTimeout=null,this.healthCheckInterval=null,this.signalingSocket=null,this.currentRoom=null,this.stats={connectTime:0,packetsLost:0,roundTripTime:0,dataChannelState:"connecting"},console.log("🔗 Connection manager initialized")}on(e,t){this.eventHandlers.has(e)||this.eventHandlers.set(e,[]),this.eventHandlers.get(e).push(t)}emit(e,t){const n=this.eventHandlers.get(e);n&&n.forEach(n=>{try{n(t)}catch(s){console.error(`Error in ${e} handler:`,s)}})}async connect(e,t=!1){if(this.isConnecting||this.isConnected)throw new Error("Connection already in progress or established");console.log(`🔗 Connecting to room: ${e} (initiator: ${t})`);const n=performance.now();try{this.isConnecting=!0,this.currentRoom=e,await this.connectToSignalingServer(),await this.joinRoom(e),await this.initializePeer(t),this.connectionTimeout=setTimeout(()=>{this.isConnected||this.handleConnectionTimeout()},3e4),this.stats.connectTime=performance.now()-n}catch(s){throw this.isConnecting=!1,console.error("Connection failed:",s),this.emit("error",s),s}}async initializePeer(e){this.peer=new s({initiator:e,trickle:!0,config:this.configuration}),this.peer.on("signal",e=>{console.log("📡 Sending signal:",e.type),this.sendSignal(e)}),this.peer.on("connect",()=>{console.log("✅ WebRTC connection established"),this.isConnected=!0,this.isConnecting=!1,this.connectionState="connected",this.stats.dataChannelState="open",this.connectionTimeout&&(clearTimeout(this.connectionTimeout),this.connectionTimeout=null),this.startHealthCheck(),this.emit("connected")}),this.peer.on("data",e=>{try{const t=JSON.parse(e.toString());this.emit("dataReceived",t)}catch(t){console.error("Failed to parse received data:",t)}}),this.peer.on("close",()=>{console.log("🔌 WebRTC connection closed"),this.handleDisconnection()}),this.peer.on("error",e=>{console.error("WebRTC error:",e),this.emit("error",e),this.shouldAttemptReconnect(e)&&this.scheduleReconnect()})}async connectToSignalingServer(){return new Promise((e,t)=>{try{const n="https:"===window.location.protocol?"wss:":"ws:",s=`${n}//${window.location.host}`;this.signalingSocket=new WebSocket(s),this.signalingSocket.onopen=()=>{console.log("📡 Connected to signaling server"),e()},this.signalingSocket.onmessage=e=>{this.handleSignalingMessage(JSON.parse(e.data))},this.signalingSocket.onclose=()=>{console.log("📡 Signaling server connection closed"),this.isConnected&&this.scheduleReconnect()},this.signalingSocket.onerror=e=>{console.error("Signaling server error:",e),t(e)}}catch(n){t(n)}})}async joinRoom(e){return new Promise((t,n)=>{if(!this.signalingSocket||this.signalingSocket.readyState!==WebSocket.OPEN)return void n(new Error("Signaling server not connected"));const s={type:"join",room:e};this.signalingSocket.send(JSON.stringify(s));const i=setTimeout(()=>{n(new Error("Room join timeout"))},1e4),o=this.handleSignalingMessage.bind(this);this.handleSignalingMessage=s=>{"joined"===s.type&&s.room===e?(clearTimeout(i),this.handleSignalingMessage=o,t()):"error"===s.type?(clearTimeout(i),this.handleSignalingMessage=o,n(new Error(s.message))):o(s)}})}handleSignalingMessage(e){switch(e.type){case"signal":this.peer&&(console.log("📡 Received signal:",e.signal.type),this.peer.signal(e.signal));break;case"peer-joined":console.log("👋 Peer joined the room"),this.peer||this.isConnecting||this.initializePeer(!0);break;case"peer-left":console.log("👋 Peer left the room"),this.handleDisconnection();break;default:console.log("Unknown signaling message:",e)}}sendSignal(e){if(this.signalingSocket&&this.signalingSocket.readyState===WebSocket.OPEN){const t={type:"signal",room:this.currentRoom,signal:e};this.signalingSocket.send(JSON.stringify(t))}}async sendData(e){if(!this.isConnected||!this.peer)throw new Error("Not connected");try{const t=JSON.stringify(e);this.peer.send(t)}catch(t){throw console.error("Failed to send data:",t),t}}startHealthCheck(){this.healthCheckInterval=setInterval(()=>{this.isConnected&&this.peer&&(this.updateConnectionStats(),this.sendPing())},3e4)}updateConnectionStats(){this.peer&&this.peer._pc&&this.peer._pc.getStats().then(e=>{e.forEach(e=>{"candidate-pair"===e.type&&"succeeded"===e.state?this.stats.roundTripTime=1e3*e.currentRoundTripTime:"transport"===e.type&&(this.stats.packetsLost=e.packetsLost||0)})}).catch(e=>{console.warn("Failed to get connection stats:",e)})}sendPing(){try{this.sendData({type:"ping",timestamp:Date.now()})}catch(e){console.warn("Failed to send ping:",e)}}handleDisconnection(){this.isConnected=!1,this.isConnecting=!1,this.connectionState="disconnected",this.stats.dataChannelState="closed",this.healthCheckInterval&&(clearInterval(this.healthCheckInterval),this.healthCheckInterval=null),this.connectionTimeout&&(clearTimeout(this.connectionTimeout),this.connectionTimeout=null),this.emit("disconnected")}handleConnectionTimeout(){console.error("⏰ Connection timeout"),this.handleDisconnection(),this.emit("error",new Error("Connection timeout"))}shouldAttemptReconnect(e){return!["ERR_CONNECTION_REFUSED","ERR_NETWORK"].includes(e.code)&&this.reconnectAttempts<this.maxReconnectAttempts}scheduleReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts)return console.error("❌ Max reconnection attempts reached"),void this.emit("error",new Error("Max reconnection attempts reached"));const e=Math.min(this.reconnectDelay*Math.pow(2,this.reconnectAttempts),3e4);this.reconnectAttempts++,console.log(`🔄 Scheduling reconnect attempt ${this.reconnectAttempts} in ${e}ms`),setTimeout(()=>{!this.isConnected&&this.currentRoom&&this.connect(this.currentRoom,!1).catch(e=>{console.error("Reconnection failed:",e),this.scheduleReconnect()})},e)}async disconnect(){console.log("🔌 Disconnecting..."),this.isConnecting=!1,this.reconnectAttempts=0,this.healthCheckInterval&&(clearInterval(this.healthCheckInterval),this.healthCheckInterval=null),this.connectionTimeout&&(clearTimeout(this.connectionTimeout),this.connectionTimeout=null),this.peer&&(this.peer.destroy(),this.peer=null),this.signalingSocket&&(this.signalingSocket.close(),this.signalingSocket=null),this.handleDisconnection()}getStats(){return{...this.stats}}getState(){return{isConnected:this.isConnected,isConnecting:this.isConnecting,connectionState:this.connectionState,currentRoom:this.currentRoom,reconnectAttempts:this.reconnectAttempts}}}),e("U",class{constructor(){this.eventHandlers=new Map,this.elements={},this.isInitialized=!1,this.currentTheme="dark",this.connectionStatus="disconnected",this.currentRoom=null,console.log("🎨 UI manager initialized")}on(e,t){this.eventHandlers.has(e)||this.eventHandlers.set(e,[]),this.eventHandlers.get(e).push(t)}emit(e,t){const n=this.eventHandlers.get(e);n&&n.forEach(n=>{try{n(t)}catch(s){console.error(`Error in ${e} handler:`,s)}})}async initialize(){console.log("🎨 Initializing UI...");try{this.cacheElements(),this.setupEventListeners(),this.initializeUIState(),this.setupResponsiveDesign(),this.isInitialized=!0,console.log("✅ UI initialized successfully")}catch(e){throw console.error("❌ Failed to initialize UI:",e),e}}cacheElements(){this.elements={modeSelection:document.getElementById("mode-selection"),hostNodeBtn:document.getElementById("host-node-btn"),joinNetworkBtn:document.getElementById("join-network-btn"),connectionPanel:document.getElementById("connection-panel"),roomInput:document.getElementById("room-id"),generateRoomBtn:document.getElementById("generate-room"),cipherSelect:document.getElementById("cipher-select"),connectBtn:document.getElementById("connect-btn"),disconnectBtn:document.getElementById("disconnect-btn"),connectionStatus:document.getElementById("connection-status"),chatPanel:document.getElementById("chat-panel"),messagesContainer:document.getElementById("messages"),messageInput:document.getElementById("message-input"),sendBtn:document.getElementById("send-btn"),debugLogs:document.getElementById("debug-logs"),clearLogsBtn:document.getElementById("clear-logs-btn"),runDebugBtn:document.getElementById("run-debug-btn"),userIdDisplay:document.getElementById("user-id-display"),peerStatus:document.getElementById("peer-status")};const e=["connectBtn","disconnectBtn","messageInput","sendBtn"];for(const t of e)if(!this.elements[t])throw new Error(`Required UI element not found: ${t}`)}setupEventListeners(){this.elements.connectBtn&&this.elements.connectBtn.addEventListener("click",()=>{const e=this.elements.roomInput?.value.trim(),t=this.elements.cipherSelect?.value||"chacha20-poly1305";e?this.emit("connect",e,t):this.showError("Please enter a room ID")}),this.elements.disconnectBtn&&this.elements.disconnectBtn.addEventListener("click",()=>{this.emit("disconnect")}),this.elements.generateRoomBtn&&this.elements.generateRoomBtn.addEventListener("click",()=>{const e=this.generateRoomId();this.elements.roomInput&&(this.elements.roomInput.value=e)}),this.elements.sendBtn&&this.elements.sendBtn.addEventListener("click",()=>{this.sendMessage()}),this.elements.messageInput&&(this.elements.messageInput.addEventListener("keypress",e=>{"Enter"!==e.key||e.shiftKey||(e.preventDefault(),this.sendMessage())}),this.elements.messageInput.addEventListener("input",()=>{this.autoResizeTextarea(this.elements.messageInput)})),this.elements.clearLogsBtn&&this.elements.clearLogsBtn.addEventListener("click",()=>{this.clearDebugLogs()}),this.elements.runDebugBtn&&this.elements.runDebugBtn.addEventListener("click",()=>{this.runDebugDiagnostics()}),this.setupAdvancedFeatureButtons()}setupAdvancedFeatureButtons(){const e=document.querySelector('[data-feature="file-sharing"]');e&&e.addEventListener("click",()=>{this.emit("loadFileManager")});const t=document.querySelector('[data-feature="voice-messages"]');t&&t.addEventListener("click",()=>{this.emit("loadVoiceManager")})}initializeUIState(){this.updateConnectionStatus("disconnected"),this.generateRandomRoomId(),this.elements.cipherSelect&&(this.elements.cipherSelect.value="chacha20-poly1305"),this.elements.roomInput&&this.elements.roomInput.focus()}setupResponsiveDesign(){window.addEventListener("resize",()=>{this.handleViewportChange()}),window.addEventListener("orientationchange",()=>{setTimeout(()=>this.handleViewportChange(),100)}),this.handleViewportChange()}handleViewportChange(){const e=window.innerWidth<=768;document.body.classList.toggle("mobile",e)}sendMessage(){const e=this.elements.messageInput?.value.trim();e&&(e.length>5e3?this.showError("Message too long (max 5000 characters)"):(this.emit("sendMessage",e),this.elements.messageInput&&(this.elements.messageInput.value="",this.autoResizeTextarea(this.elements.messageInput))))}updateConnectionStatus(e){this.connectionStatus=e,this.elements.connectionStatus&&(this.elements.connectionStatus.textContent=this.getStatusText(e),this.elements.connectionStatus.className=`status status-${e}`);const t="connected"===e,n="connecting"===e;this.elements.connectBtn&&(this.elements.connectBtn.disabled=t||n,this.elements.connectBtn.textContent=n?"Connecting...":"Connect"),this.elements.disconnectBtn&&(this.elements.disconnectBtn.disabled=!t&&!n),this.elements.messageInput&&(this.elements.messageInput.disabled=!t),this.elements.sendBtn&&(this.elements.sendBtn.disabled=!t),this.elements.chatPanel&&this.elements.chatPanel.classList.toggle("hidden",!t)}getStatusText(e){return{disconnected:"Disconnected",connecting:"Connecting...",connected:"Connected",error:"Connection Error"}[e]||e}displayMessage(e){if(!this.elements.messagesContainer)return;const t=this.createMessageElement(e);this.elements.messagesContainer.appendChild(t),this.scrollToBottom(),this.removeEncryptionNotice()}createMessageElement(e){const t=document.createElement("div");t.className="message "+("self"===e.sender?"message-sent":"message-received");const n=new Date(e.timestamp).toLocaleTimeString();return t.innerHTML=`\n            <div class="message-content">\n                <div class="message-text">${this.escapeHtml(e.text)}</div>\n                <div class="message-time">${n}</div>\n                ${e.encrypted?'<div class="message-encrypted"><i class="fas fa-lock"></i></div>':""}\n            </div>\n        `,t}removeEncryptionNotice(){const e=this.elements.messagesContainer?.querySelector(".encryption-notice");e&&e.remove()}scrollToBottom(){this.elements.messagesContainer&&(this.elements.messagesContainer.scrollTop=this.elements.messagesContainer.scrollHeight)}showError(e){const t=document.createElement("div");t.className="error-notification",t.innerHTML=`\n            <i class="fas fa-exclamation-triangle"></i>\n            <span>${this.escapeHtml(e)}</span>\n            <button class="error-close" onclick="this.parentElement.remove()">×</button>\n        `,document.body.appendChild(t),setTimeout(()=>{t.parentElement&&t.remove()},5e3)}showSuccess(e){const t=document.createElement("div");t.className="success-notification",t.innerHTML=`\n            <i class="fas fa-check-circle"></i>\n            <span>${this.escapeHtml(e)}</span>\n            <button class="success-close" onclick="this.parentElement.remove()">×</button>\n        `,document.body.appendChild(t),setTimeout(()=>{t.parentElement&&t.remove()},3e3)}generateRandomRoomId(){const e=this.generateRoomId();this.elements.roomInput&&(this.elements.roomInput.value=e)}generateRoomId(){return Array.from(crypto.getRandomValues(new Uint8Array(8))).map(e=>e.toString(16).padStart(2,"0")).join("").toUpperCase()}autoResizeTextarea(e){e.style.height="auto",e.style.height=Math.min(e.scrollHeight,120)+"px"}clearDebugLogs(){this.elements.debugLogs&&(this.elements.debugLogs.textContent="CipherWave Debug Console - Ready")}addDebugLog(e,t="info"){if(!this.elements.debugLogs)return;const n=`[${(new Date).toLocaleTimeString()}] ${t.toUpperCase()}: ${e}`;this.elements.debugLogs.textContent+="\n"+n,this.elements.debugLogs.scrollTop=this.elements.debugLogs.scrollHeight}runDebugDiagnostics(){this.addDebugLog("Running diagnostics...","info"),window.RTCPeerConnection?this.addDebugLog("✅ WebRTC supported","success"):this.addDebugLog("❌ WebRTC not supported","error"),window.crypto&&window.crypto.getRandomValues?this.addDebugLog("✅ Crypto API supported","success"):this.addDebugLog("❌ Crypto API not supported","error"),window.WebSocket?this.addDebugLog("✅ WebSocket supported","success"):this.addDebugLog("❌ WebSocket not supported","error"),this.addDebugLog("Diagnostics complete","info")}escapeHtml(e){const t=document.createElement("div");return t.textContent=e,t.innerHTML}getState(){return{isInitialized:this.isInitialized,connectionStatus:this.connectionStatus,currentRoom:this.currentRoom,theme:this.currentTheme}}destroy(){this.eventHandlers.clear(),this.elements={},this.isInitialized=!1,console.log("🗑️ UI manager destroyed")}})}}});
//# sourceMappingURL=chunk-legacy-DcY-LF2r.js.map
