{"version":3,"file":"index-legacy-CgY4zHRK.js","sources":["../../script.js"],"sourcesContent":["// CipherWave - Secure P2P Messenger\n// script.js\n\n// DOM Elements\nconst modeSelection = document.getElementById('mode-selection');\nconst nodePanel = document.getElementById('node-panel');\nconst connectionPanel = document.getElementById('connection-panel');\nconst chatPanel = document.getElementById('chat-panel');\nconst debugPanel = document.getElementById('debug-panel');\nconst hostNodeBtn = document.getElementById('host-node-btn');\nconst joinNetworkBtn = document.getElementById('join-network-btn');\nconst nodePortInput = document.getElementById('node-port');\nconst startNodeBtn = document.getElementById('start-node-btn');\nconst stopNodeBtn = document.getElementById('stop-node-btn');\nconst nodeStatus = document.getElementById('node-status');\nconst roomInput = document.getElementById('room-id');\nconst generateRoomBtn = document.getElementById('generate-room');\nconst cipherSelect = document.getElementById('cipher-select');\nconst connectBtn = document.getElementById('connect-btn');\nconst disconnectBtn = document.getElementById('disconnect-btn');\nconst connectionStatus = document.getElementById('connection-status');\nconst messagesContainer = document.getElementById('messages');\nconst messageInput = document.getElementById('message-input');\nconst sendBtn = document.getElementById('send-btn');\nconst chatToggle = document.getElementById('chat-toggle');\nconst debugToggle = document.getElementById('debug-toggle');\nconst debugLogs = document.getElementById('debug-logs');\nconst clearLogsBtn = document.getElementById('clear-logs-btn');\nconst runDebugBtn = document.getElementById('run-debug-btn');\nconst userIdDisplay = document.getElementById('user-id-display');\nconst peerStatus = document.getElementById('peer-status');\n\n// Application State\nlet peerConnection = null;\nlet dataChannel = null;\nlet isConnected = false;\nlet isInitiator = false;\nlet currentCipher = 'aes';\nlet encryptionKey = null;\nlet room = null;\nlet nodeServer = null;\nlet signalingSocket = null;\nlet pendingMessages = new Map(); // For message delivery confirmations\nlet messageCounter = 0;\nlet userId = null;\n\n// Configuration for WebRTC with fallback options\nconst configuration = {\n    iceServers: [\n        // STUN servers\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun.stunprotocol.org:3478' },\n        { urls: 'stun:stun.voiparound.com' },\n        { urls: 'stun:stun.voipbuster.com' },\n        { urls: 'stun:stun.voipstunt.com' },\n        { urls: 'stun:stun.xten.com' },\n        \n        // TURN servers (for better NAT traversal)\n        { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },\n        { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },\n        { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' },\n        \n        // Fallback TURN servers\n        { urls: 'turn:freeturn.net:3478', username: 'free', credential: 'free' },\n        { urls: 'turn:freeturn.net:5349', username: 'free', credential: 'free' },\n        { urls: 'turns:freeturn.net:5349', username: 'free', credential: 'free' },\n        \n        // Additional public TURN servers for testing\n        { urls: 'turn:turn.anyfirewall.com:443?transport=tcp', username: 'webrtc', credential: 'webrtc' },\n        { urls: 'turn:turn.bistri.com:80', username: 'homeo', credential: 'homeo' }\n    ],\n    iceCandidatePoolSize: 10,\n    iceTransportPolicy: 'all',\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require'\n};\n\n// Function to validate TURN server credentials\nfunction validateTurnCredentials(iceServers) {\n    return iceServers.map(server => {\n        if (server.urls.startsWith('turn:') && (!server.username || !server.credential)) {\n            console.warn('TURN server missing credentials:', server.urls);\n            // Remove the server from the list if credentials are missing\n            return null;\n        }\n        return server;\n    }).filter(server => server !== null);\n}\n\n// Validate and filter ICE servers\nconst validatedIceServers = validateTurnCredentials(configuration.iceServers);\nconfiguration.iceServers = validatedIceServers;\n\n// Connection timeout values\nconst CONNECTION_TIMEOUT = 60000; // 60 seconds\nconst ICE_TIMEOUT = 30000; // 30 seconds\n\n// Connection state tracking for debugging\nlet connectionStateLog = [];\n\n// List of known signaling servers for automatic discovery\nconst knownServers = [\n    'ws://localhost:52178',\n    'ws://localhost:8081',\n    'ws://localhost:8082'\n];\n\n// WebSocket signaling for peer connection\nconst signaling = {\n    connect: function(serverUrl, roomId) {\n        return new Promise((resolve, reject) => {\n            signalingSocket = new WebSocket(serverUrl);\n            signalingSocket.onopen = () => {\n                signalingSocket.send(JSON.stringify({ type: 'join', room: roomId }));\n                resolve();\n            };\n            signalingSocket.onerror = (err) => {\n                console.error('Signaling socket error:', err);\n                reject(err);\n            };\n        });\n    },\n    send: function(message) {\n        if (signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {\n            signalingSocket.send(JSON.stringify({ ...message, room }));\n        }\n    },\n    onMessage: function(callback) {\n        if (signalingSocket) {\n            signalingSocket.onmessage = (event) => {\n                try {\n                    const data = JSON.parse(event.data);\n                    callback(data);\n                } catch (e) {\n                    console.error('Signaling message parse error:', e);\n                }\n            };\n        }\n    },\n    disconnect: function() {\n        if (signalingSocket) {\n            signalingSocket.close();\n            signalingSocket = null;\n        }\n    }\n};\n\n// Node server management\nconst nodeManager = {\n    start: function(port) {\n        // In a browser environment, we can't actually start a server\n        // This would require a separate Node.js process\n        // For demo purposes, we'll simulate node hosting\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                // Simulate starting a node\n                updateNodeStatus('Node Running on port ' + port, 'status-running');\n                startNodeBtn.disabled = true;\n                stopNodeBtn.disabled = false;\n                resolve();\n            }, 1000);\n        });\n    },\n    stop: function() {\n        // Simulate stopping a node\n        updateNodeStatus('Node Stopped', 'status-stopped');\n        startNodeBtn.disabled = false;\n        stopNodeBtn.disabled = true;\n    }\n};\n\n// Automatic server discovery\nasync function discoverServer(roomId) {\n    updateConnectionStatus('Discovering network...', 'status-disconnected');\n    \n    // Try each known server until one works\n    for (const server of knownServers) {\n        try {\n            updateConnectionStatus(`Trying ${server}...`, 'status-disconnected');\n            await signaling.connect(server, roomId);\n            return server;\n        } catch (err) {\n            console.log(`Failed to connect to ${server}`);\n            continue;\n        }\n    }\n    \n    throw new Error('No available signaling servers found');\n}\n\n// Generate a random room ID\nfunction generateRoomId() {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let roomId = '';\n    for (let i = 0; i < 20; i++) {\n        roomId += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return roomId;\n}\n\n// Generate a unique user ID\nfunction generateUserId() {\n    const prefix = 'CW';\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let id = prefix + '-';\n    for (let i = 0; i < 6; i++) {\n        id += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return id;\n}\n\n// Update node status display\nfunction updateNodeStatus(text, className) {\n    nodeStatus.textContent = text;\n    nodeStatus.className = className;\n}\n\n// Update connection status display\nfunction updateConnectionStatus(text, className) {\n    connectionStatus.textContent = text;\n    connectionStatus.className = className;\n    \n    // Update peer status in chat header\n    if (peerStatus) {\n        peerStatus.textContent = text;\n        if (className.includes('connected')) {\n            peerStatus.style.color = '#4CAF50';\n        } else if (className.includes('disconnected')) {\n            peerStatus.style.color = '#F44336';\n        } else {\n            peerStatus.style.color = '#FF9800';\n        }\n    }\n}\n\n// Mode selection\nhostNodeBtn.addEventListener('click', () => {\n    modeSelection.classList.add('hidden');\n    nodePanel.classList.remove('hidden');\n});\n\njoinNetworkBtn.addEventListener('click', () => {\n    modeSelection.classList.add('hidden');\n    connectionPanel.classList.remove('hidden');\n});\n\n// Node management\nstartNodeBtn.addEventListener('click', async () => {\n    const port = nodePortInput.value || 8080;\n    updateNodeStatus('Starting node...', 'status-stopped');\n    try {\n        await nodeManager.start(port);\n    } catch (err) {\n        updateNodeStatus('Failed to start node', 'status-stopped');\n    }\n});\n\nstopNodeBtn.addEventListener('click', () => {\n    nodeManager.stop();\n});\n\n// Generate room ID on button click\ngenerateRoomBtn.addEventListener('click', () => {\n    roomInput.value = generateRoomId();\n});\n\n// Update cipher selection\ncipherSelect.addEventListener('change', () => {\n    currentCipher = cipherSelect.value;\n});\n\n// Connect to room\nconnectBtn.addEventListener('click', async () => {\n    room = roomInput.value.trim();\n    if (!room) {\n        alert('Please enter or generate a room ID');\n        return;\n    }\n\n    // Set connection status\n    updateConnectionStatus('Discovering network...', 'status-disconnected');\n\n    // Discover and connect to signaling server\n    let serverUrl;\n    try {\n        serverUrl = await discoverServer(room);\n    } catch (err) {\n        updateConnectionStatus('No available servers', 'status-disconnected');\n        return;\n    }\n\n    // Initialize encryption\n    await initializeEncryption();\n\n    // Set up signaling message handler\n    signaling.onMessage((msg) => {\n        if (msg.type === 'init') {\n            isInitiator = msg.initiator;\n            // Start WebRTC connection after receiving init message\n            startConnection();\n        } else if (msg.type === 'key') {\n            // Handle key exchange message\n            handleKeyExchange(msg);\n        } else {\n            handleSignalingMessage(msg);\n        }\n    });\n});\n\n// Log connection state for debugging\nfunction logConnectionState(state) {\n    const timestamp = new Date().toLocaleTimeString();\n    connectionStateLog.push(`${timestamp}: ${state}`);\n    console.log(`[Connection Log] ${timestamp}: ${state}`);\n    \n    // Update debug panel in real-time\n    if (typeof debugLogs !== 'undefined' && debugLogs) {\n        const logEntry = document.createElement('div');\n        logEntry.className = 'debug-log-entry';\n        logEntry.textContent = `[${timestamp}] ${state}`;\n        debugLogs.appendChild(logEntry);\n        \n        // Scroll to bottom\n        debugLogs.scrollTop = debugLogs.scrollHeight;\n    }\n}\n\n// Start WebRTC connection\nfunction startConnection() {\n    try {\n        // Update connection status\n        updateConnectionStatus('Establishing peer connection...', 'status-disconnected');\n        logConnectionState('Starting WebRTC connection setup');\n        \n        // Create peer connection\n        peerConnection = new RTCPeerConnection(configuration);\n        logConnectionState('RTCPeerConnection created');\n        \n        // Set up connection timeout\n        const connectionTimeout = setTimeout(() => {\n            if (peerConnection.connectionState !== 'connected' && \n                peerConnection.connectionState !== 'completed') {\n                logConnectionState('Connection timeout - no connection established');\n                updateConnectionStatus('Connection timeout', 'status-disconnected');\n                \n                // Try to restart ICE if connection is still trying\n                if (peerConnection.iceConnectionState === 'checking' || \n                    peerConnection.iceConnectionState === 'disconnected') {\n                    logConnectionState('Attempting ICE restart after timeout');\n                    peerConnection.restartIce();\n                }\n            }\n        }, CONNECTION_TIMEOUT);\n        \n        // Log connection state changes\n        peerConnection.onconnectionstatechange = () => {\n            logConnectionState(`Connection state: ${peerConnection.connectionState}`);\n            updateConnectionStatus(`Connection: ${peerConnection.connectionState}`, 'status-disconnected');\n            \n            // Clear timeout if connection is established\n            if (peerConnection.connectionState === 'connected' || \n                peerConnection.connectionState === 'completed') {\n                clearTimeout(connectionTimeout);\n            }\n            \n            // Handle connection failure\n            if (peerConnection.connectionState === 'failed') {\n                logConnectionState('Connection failed, attempting to restart ICE');\n                peerConnection.restartIce();\n            }\n            \n            // Handle disconnected state\n            if (peerConnection.connectionState === 'disconnected') {\n                logConnectionState('Connection disconnected, monitoring for reconnection');\n                // Set a timeout to restart ICE if we don't reconnect quickly\n                setTimeout(() => {\n                    if (peerConnection.connectionState === 'disconnected') {\n                        logConnectionState('Connection still disconnected, attempting to restart ICE');\n                        peerConnection.restartIce();\n                    }\n                }, 10000);\n            }\n        };\n        \n        peerConnection.onsignalingstatechange = () => {\n            logConnectionState(`Signaling state: ${peerConnection.signalingState}`);\n        };\n        \n        peerConnection.oniceconnectionstatechange = () => {\n            logConnectionState(`ICE connection state: ${peerConnection.iceConnectionState}`);\n            \n            // Handle ICE connection failure\n            if (peerConnection.iceConnectionState === 'failed') {\n                logConnectionState('ICE connection failed, attempting to restart ICE');\n                peerConnection.restartIce();\n            }\n            \n            // Handle ICE disconnection\n            if (peerConnection.iceConnectionState === 'disconnected') {\n                logConnectionState('ICE connection disconnected, monitoring for reconnection');\n            }\n        };\n        \n        peerConnection.onicegatheringstatechange = () => {\n            logConnectionState(`ICE gathering state: ${peerConnection.iceGatheringState}`);\n            \n            // Set ICE gathering timeout\n            if (peerConnection.iceGatheringState === 'gathering') {\n                setTimeout(() => {\n                    if (peerConnection.iceGatheringState === 'gathering') {\n                        logConnectionState('ICE gathering timeout - forcing completion');\n                        // Force completion by creating a null candidate\n                        peerConnection.onicecandidate({ candidate: null });\n                    }\n                }, ICE_TIMEOUT);\n            }\n        };\n        \n        // Handle ICE candidates with better error handling\n        peerConnection.onicecandidate = event => {\n            if (event.candidate) {\n                logConnectionState(`ICE candidate gathered: ${event.candidate.type} (${event.candidate.protocol})`);\n                signaling.send({\n                    type: 'candidate',\n                    candidate: event.candidate\n                });\n            } else {\n                logConnectionState('ICE candidate gathering complete');\n            }\n        };\n        \n        // Handle ICE candidate errors with fallback\n        peerConnection.onicecandidateerror = event => {\n            logConnectionState(`ICE candidate error: ${event.errorCode} - ${event.errorText} (${event.url})`);\n            console.error('ICE candidate error:', event);\n            \n            // Try to continue with available candidates\n            if (peerConnection.iceGatheringState === 'complete') {\n                logConnectionState('ICE gathering completed despite errors');\n            }\n            \n            // If we're still gathering, try to restart ICE after a delay\n            if (peerConnection.iceGatheringState === 'gathering') {\n                logConnectionState('Attempting to restart ICE after candidate error');\n                setTimeout(() => {\n                    if (peerConnection.iceGatheringState === 'gathering') {\n                        logConnectionState('Forcing ICE gathering completion after error');\n                        // Force completion by creating a null candidate\n                        peerConnection.onicecandidate({ candidate: null });\n                    }\n                }, 5000);\n            }\n        };\n        \n        // Handle data channel\n        if (isInitiator) {\n            logConnectionState('Creating data channel (initiator)');\n            // Create data channel for initiator with better configuration\n            dataChannel = peerConnection.createDataChannel('messaging', {\n                ordered: true,\n                maxRetransmits: 3\n            });\n            setupDataChannel(dataChannel);\n            \n            // Create offer with better configuration\n            logConnectionState('Creating offer');\n            peerConnection.createOffer({\n                offerToReceiveAudio: false,\n                offerToReceiveVideo: false\n            })\n                .then(offer => {\n                    logConnectionState('Offer created, setting local description');\n                    return peerConnection.setLocalDescription(offer);\n                })\n                .then(() => {\n                    logConnectionState('Local description set, sending offer');\n                    signaling.send({\n                        type: 'offer',\n                        offer: peerConnection.localDescription\n                    });\n                })\n                .catch(error => {\n                    logConnectionState(`Error creating offer: ${error.message}`);\n                    console.error('Error creating offer:', error);\n                    updateConnectionStatus('Connection failed', 'status-disconnected');\n                });\n        } else {\n            logConnectionState('Waiting for data channel (non-initiator)');\n            // Handle incoming data channel for non-initiator with better configuration\n            peerConnection.ondatachannel = event => {\n                logConnectionState('Data channel received');\n                dataChannel = event.channel;\n                dataChannel.binaryType = 'arraybuffer';\n                setupDataChannel(dataChannel);\n            };\n        }\n        \n    } catch (error) {\n        logConnectionState(`Error starting connection: ${error.message}`);\n        console.error('Error starting connection:', error);\n        updateConnectionStatus('Connection failed', 'status-disconnected');\n    }\n}\n\n// Handle signaling messages\nfunction handleSignalingMessage(message) {\n    if (!peerConnection) {\n        logConnectionState('Received signaling message but no peer connection exists');\n        return;\n    }\n    \n    logConnectionState(`Received signaling message: ${message.type}`);\n    \n    switch (message.type) {\n        case 'offer':\n            logConnectionState('Processing offer');\n            peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer))\n                .then(() => {\n                    logConnectionState('Remote offer set, creating answer');\n                    return peerConnection.createAnswer();\n                })\n                .then(answer => {\n                    logConnectionState('Answer created, setting local description');\n                    return peerConnection.setLocalDescription(answer);\n                })\n                .then(() => {\n                    logConnectionState('Local answer set, sending answer');\n                    signaling.send({\n                        type: 'answer',\n                        answer: peerConnection.localDescription\n                    });\n                })\n                .catch(error => {\n                    logConnectionState(`Error handling offer: ${error.message}`);\n                    console.error('Error handling offer:', error);\n                });\n            break;\n            \n        case 'answer':\n            logConnectionState('Processing answer');\n            peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer))\n                .then(() => {\n                    logConnectionState('Remote answer set successfully');\n                })\n                .catch(error => {\n                    logConnectionState(`Error handling answer: ${error.message}`);\n                    console.error('Error handling answer:', error);\n                });\n            break;\n            \n        case 'candidate':\n            logConnectionState(`Adding ICE candidate: ${message.candidate.type}`);\n            peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate))\n                .then(() => {\n                    logConnectionState('ICE candidate added successfully');\n                })\n                .catch(error => {\n                    logConnectionState(`Error adding ICE candidate: ${error.message}`);\n                    console.error('Error adding ICE candidate:', error);\n                });\n            break;\n            \n        default:\n            logConnectionState(`Unknown signaling message type: ${message.type}`);\n    }\n}\n\n// Setup data channel\nfunction setupDataChannel(channel) {\n    channel.onopen = () => {\n        isConnected = true;\n        updateConnectionStatus('Connected', 'status-connected');\n        connectBtn.disabled = true;\n        disconnectBtn.disabled = false;\n        \n        // Show chat panel\n        connectionPanel.classList.add('hidden');\n        chatPanel.classList.remove('hidden');\n    };\n    \n    channel.onclose = () => {\n        isConnected = false;\n        updateConnectionStatus('Disconnected', 'status-disconnected');\n        connectBtn.disabled = false;\n        disconnectBtn.disabled = true;\n        \n        // Show connection panel\n        chatPanel.classList.add('hidden');\n        connectionPanel.classList.remove('hidden');\n    };\n    \n    channel.onerror = (error) => {\n        logConnectionState(`Data channel error: ${error.message}`);\n        console.error('Data channel error:', error);\n        \n        // If we're still connected, try to restart the data channel\n        if (isConnected) {\n            logConnectionState('Attempting to restart data channel after error');\n            isConnected = false;\n            updateConnectionStatus('Data channel error, reconnecting...', 'status-disconnected');\n            \n            // Try to restart the connection after a short delay\n            setTimeout(() => {\n                if (peerConnection && peerConnection.connectionState !== 'connected') {\n                    logConnectionState('Restarting ICE after data channel error');\n                    peerConnection.restartIce();\n                }\n            }, 2000);\n        }\n    };\n    \n    channel.onmessage = event => {\n        try {\n            const data = JSON.parse(event.data);\n            if (data.type === 'message') {\n                // Decrypt message\n                const decryptedMessage = decryptMessage(data.content, currentCipher);\n                displayMessage(decryptedMessage, 'received');\n            } else if (data.type === 'delivery-confirmation') {\n                // Handle message delivery confirmation\n                const messageElement = document.querySelector(`[data-message-id=\"${data.messageId}\"]`);\n                if (messageElement) {\n                    const statusElement = messageElement.querySelector('.message-status');\n                    if (statusElement) {\n                        statusElement.textContent = '✓✓';\n                        statusElement.className = 'message-status delivered';\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error processing message:', error);\n        }\n    };\n}\n\n// Disconnect from room\ndisconnectBtn.addEventListener('click', () => {\n    if (dataChannel) {\n        dataChannel.close();\n    }\n    if (peerConnection) {\n        peerConnection.close();\n    }\n\n    signaling.disconnect();\n\n    isConnected = false;\n    updateConnectionStatus('Disconnected', 'status-disconnected');\n    connectBtn.disabled = false;\n    disconnectBtn.disabled = true;\n\n    // Show connection panel\n    chatPanel.classList.add('hidden');\n    connectionPanel.classList.remove('hidden');\n\n    // Clear messages\n    messagesContainer.innerHTML = '';\n    \n    // Clear pending messages\n    pendingMessages.clear();\n});\n\n// Send message\nsendBtn.addEventListener('click', sendMessage);\nmessageInput.addEventListener('keypress', (e) => {\n    if (e.key === 'Enter') {\n        sendMessage();\n    }\n});\n\n// Send message function\nfunction sendMessage() {\n    const message = messageInput.value.trim();\n    if (!message || !isConnected || !dataChannel) return;\n    \n    try {\n        // Encrypt message\n        const encryptedMessage = encryptMessage(message, currentCipher);\n        \n        // Create message ID for tracking\n        const messageId = ++messageCounter;\n        \n        // Send via data channel\n        const messageData = {\n            type: 'message',\n            content: encryptedMessage,\n            timestamp: Date.now(),\n            messageId: messageId\n        };\n        \n        dataChannel.send(JSON.stringify(messageData));\n        displayMessage(message, 'sent', messageId);\n        messageInput.value = '';\n        \n        // Track pending message for delivery confirmation\n        pendingMessages.set(messageId, {\n            content: message,\n            timestamp: Date.now()\n        });\n        \n        // Set timeout for delivery confirmation\n        setTimeout(() => {\n            if (pendingMessages.has(messageId)) {\n                const messageElement = document.querySelector(`[data-message-id=\"${messageId}\"]`);\n                if (messageElement) {\n                    const statusElement = messageElement.querySelector('.message-status');\n                    if (statusElement && statusElement.textContent === '✓') {\n                        statusElement.textContent = '⚠';\n                        statusElement.className = 'message-status not-delivered';\n                    }\n                }\n                pendingMessages.delete(messageId);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('Error sending message:', error);\n        alert('Failed to send message');\n    }\n}\n\n// Display message in UI\nfunction displayMessage(message, type, messageId = null) {\n    const messageElement = document.createElement('div');\n    messageElement.className = `message ${type}`;\n    \n    if (messageId) {\n        messageElement.setAttribute('data-message-id', messageId);\n    }\n    \n    const messageContent = document.createElement('div');\n    messageContent.className = 'message-content';\n    messageContent.textContent = message;\n    \n    const messageInfo = document.createElement('div');\n    messageInfo.className = 'message-info';\n    messageInfo.textContent = new Date().toLocaleTimeString();\n    \n    // Add delivery status indicator for sent messages\n    if (type === 'sent') {\n        const statusElement = document.createElement('span');\n        statusElement.className = 'message-status';\n        statusElement.textContent = '✓';\n        messageInfo.appendChild(statusElement);\n    }\n    \n    messageElement.appendChild(messageContent);\n    messageElement.appendChild(messageInfo);\n    messagesContainer.appendChild(messageElement);\n    \n    // Scroll to bottom\n    messagesContainer.scrollTop = messagesContainer.scrollHeight;\n}\n\n// Initialize encryption based on selected cipher\nasync function initializeEncryption() {\n    switch (currentCipher) {\n        case 'aes':\n            // Generate a random key for AES\n            encryptionKey = CryptoJS.lib.WordArray.random(256/8);\n            break;\n        case 'rsa':\n            // In a real implementation, we would generate RSA keys\n            // For demo, we'll use a placeholder\n            encryptionKey = 'rsa-key-placeholder';\n            break;\n        case 'chacha20':\n            // Generate a random key for ChaCha20\n            encryptionKey = CryptoJS.lib.WordArray.random(256/8);\n            break;\n    }\n    \n    // For demo purposes, we'll share the key through the signaling channel\n    // In a real implementation, this would be done through a secure key exchange\n    if (isInitiator) {\n        setTimeout(() => {\n            signaling.send({\n                type: 'key',\n                cipher: currentCipher,\n                key: encryptionKey.toString()\n            });\n        }, 2000);\n    }\n}\n\n// Handle incoming key exchange messages\nfunction handleKeyExchange(message) {\n    if (message.type === 'key') {\n        // Set the encryption key received from the initiator\n        encryptionKey = CryptoJS.enc.Hex.parse(message.key);\n        logConnectionState(`Encryption key received for ${message.cipher}`);\n    }\n}\n\n// Encrypt message based on selected cipher\nfunction encryptMessage(message, cipher) {\n    switch (cipher) {\n        case 'aes':\n            return CryptoJS.AES.encrypt(message, encryptionKey).toString();\n        case 'rsa':\n            // In a real implementation, we would use RSA encryption\n            // For demo, we'll just base64 encode\n            return btoa(message);\n        case 'chacha20':\n            // ChaCha20 implementation would go here\n            // For demo, we'll use AES as a substitute\n            return CryptoJS.AES.encrypt(message, encryptionKey).toString();\n        default:\n            return message;\n    }\n}\n\n// Decrypt message based on selected cipher\nfunction decryptMessage(encryptedMessage, cipher) {\n    try {\n        switch (cipher) {\n            case 'aes':\n                const decrypted = CryptoJS.AES.decrypt(encryptedMessage, encryptionKey);\n                return decrypted.toString(CryptoJS.enc.Utf8);\n            case 'rsa':\n                // In a real implementation, we would use RSA decryption\n                // For demo, we'll just base64 decode\n                return atob(encryptedMessage);\n            case 'chacha20':\n                // ChaCha20 implementation would go here\n                // For demo, we'll use AES as a substitute\n                const chachaDecrypted = CryptoJS.AES.decrypt(encryptedMessage, encryptionKey);\n                return chachaDecrypted.toString(CryptoJS.enc.Utf8);\n            default:\n                return encryptedMessage;\n        }\n    } catch (error) {\n        console.error('Decryption error:', error);\n        return '[Decryption Error]';\n    }\n}\n\n// Initialize the application\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Set initial states\n    updateNodeStatus('Node Stopped', 'status-stopped');\n    updateConnectionStatus('Disconnected', 'status-disconnected');\n    \n    // Generate a room ID by default\n    roomInput.value = generateRoomId();\n    \n    // Generate and display user ID\n    userId = generateUserId();\n    if (userIdDisplay) {\n        userIdDisplay.textContent = userId;\n    }\n    \n    // Show debug panel\n    debugPanel.classList.remove('hidden');\n});\n\n// Expandable panel functionality\nchatToggle.addEventListener('click', () => {\n    const content = document.querySelector('#messages');\n    if (content.style.display === 'none') {\n        content.style.display = 'block';\n        chatToggle.textContent = '▼';\n    } else {\n        content.style.display = 'none';\n        chatToggle.textContent = '▶';\n    }\n});\n\ndebugToggle.addEventListener('click', () => {\n    const content = document.querySelector('#debug-content');\n    if (content.style.display === 'none') {\n        content.style.display = 'block';\n        debugToggle.textContent = '▼';\n    } else {\n        content.style.display = 'none';\n        debugToggle.textContent = '▶';\n    }\n});\n\n// Debug panel functionality\nclearLogsBtn.addEventListener('click', () => {\n    debugLogs.innerHTML = '';\n    connectionStateLog = [];\n});\n\nrunDebugBtn.addEventListener('click', () => {\n    // Run the debug connection function\n    debugConnection();\n});\n\n// Enhanced debug connection function\nfunction debugConnection() {\n    const logEntry = document.createElement('div');\n    logEntry.className = 'debug-log-entry';\n    \n    let debugInfo = `=== CipherWave Debug Report ===\\n`;\n    debugInfo += `Time: ${new Date().toLocaleString()}\\n`;\n    debugInfo += `User ID: ${userId || 'Not generated'}\\n\\n`;\n    \n    // Check if required APIs are available\n    debugInfo += `WebRTC Support: ${!!window.RTCPeerConnection}\\n`;\n    debugInfo += `WebSocket Support: ${!!window.WebSocket}\\n`;\n    debugInfo += `Crypto Support: ${!!window.crypto}\\n\\n`;\n    \n    // Check network connectivity\n    debugInfo += `Online Status: ${navigator.onLine}\\n\\n`;\n    \n    // Check signaling server connection\n    if (typeof signalingSocket !== 'undefined' && signalingSocket) {\n        debugInfo += `Signaling Server Status: ${signalingSocket.readyState}\\n`;\n        debugInfo += `Signaling Server URL: ${signalingSocket.url || 'N/A'}\\n\\n`;\n    } else {\n        debugInfo += `Signaling Server: Not connected\\n\\n`;\n    }\n    \n    // Check WebRTC connection\n    if (typeof peerConnection !== 'undefined' && peerConnection) {\n        debugInfo += `Peer Connection State: ${peerConnection.connectionState}\\n`;\n        debugInfo += `Signaling State: ${peerConnection.signalingState}\\n`;\n        debugInfo += `ICE Connection State: ${peerConnection.iceConnectionState}\\n`;\n        debugInfo += `ICE Gathering State: ${peerConnection.iceGatheringState}\\n\\n`;\n    } else {\n        debugInfo += `Peer Connection: Not established\\n\\n`;\n    }\n    \n    // Check data channel\n    if (typeof dataChannel !== 'undefined' && dataChannel) {\n        debugInfo += `Data Channel State: ${dataChannel.readyState}\\n`;\n        debugInfo += `Data Channel Label: ${dataChannel.label}\\n\\n`;\n    } else {\n        debugInfo += `Data Channel: Not established\\n\\n`;\n    }\n    \n    // Display connection log\n    if (typeof connectionStateLog !== 'undefined' && connectionStateLog && connectionStateLog.length > 0) {\n        debugInfo += `=== Recent Connection Events ===\\n`;\n        // Show last 10 log entries\n        const recentLogs = connectionStateLog.slice(-10);\n        debugInfo += recentLogs.join('\\n');\n    } else {\n        debugInfo += `=== No Connection Events ===\\n`;\n    }\n    \n    debugInfo += `\\n=== End Debug Report ===`;\n    \n    logEntry.textContent = debugInfo;\n    debugLogs.appendChild(logEntry);\n    \n    // Scroll to bottom\n    debugLogs.scrollTop = debugLogs.scrollHeight;\n}\n"],"names":["modeSelection","document","getElementById","nodePanel","connectionPanel","chatPanel","debugPanel","hostNodeBtn","joinNetworkBtn","nodePortInput","startNodeBtn","stopNodeBtn","nodeStatus","roomInput","generateRoomBtn","cipherSelect","connectBtn","disconnectBtn","connectionStatus","messagesContainer","messageInput","sendBtn","chatToggle","debugToggle","debugLogs","clearLogsBtn","runDebugBtn","userIdDisplay","peerStatus","peerConnection","dataChannel","isConnected","isInitiator","currentCipher","encryptionKey","room","signalingSocket","pendingMessages","Map","messageCounter","userId","configuration","iceServers","urls","username","credential","iceCandidatePoolSize","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","validatedIceServers","map","server","startsWith","console","warn","filter","connectionStateLog","knownServers","signaling","serverUrl","roomId","Promise","resolve","reject","WebSocket","onopen","send","JSON","stringify","type","onerror","err","error","message","readyState","OPEN","callback","onmessage","event","data","parse","e","close","nodeManager","port","setTimeout","updateNodeStatus","disabled","generateRoomId","chars","i","charAt","Math","floor","random","text","className","textContent","updateConnectionStatus","includes","style","color","logConnectionState","state","timestamp","Date","toLocaleTimeString","push","log","logEntry","createElement","appendChild","scrollTop","scrollHeight","setupDataChannel","channel","classList","add","remove","onclose","connectionState","restartIce","displayMessage","encryptedMessage","cipher","CryptoJS","AES","decrypt","toString","enc","Utf8","atob","decryptMessage","content","messageElement","querySelector","messageId","statusElement","sendMessage","value","trim","encrypt","btoa","encryptMessage","messageData","now","set","has","delete","alert","setAttribute","messageContent","messageInfo","addEventListener","async","Error","discoverServer","lib","WordArray","key","initializeEncryption","msg","initiator","RTCPeerConnection","connectionTimeout","iceConnectionState","onconnectionstatechange","clearTimeout","onsignalingstatechange","signalingState","oniceconnectionstatechange","onicegatheringstatechange","iceGatheringState","onicecandidate","candidate","protocol","onicecandidateerror","errorCode","errorText","url","createDataChannel","ordered","maxRetransmits","createOffer","offerToReceiveAudio","offerToReceiveVideo","then","offer","setLocalDescription","localDescription","catch","ondatachannel","binaryType","startConnection","Hex","setRemoteDescription","RTCSessionDescription","createAnswer","answer","addIceCandidate","RTCIceCandidate","handleSignalingMessage","innerHTML","clear","id","prefix","generateUserId","display","debugInfo","toLocaleString","window","crypto","navigator","onLine","label","length","slice","join","debugConnection"],"mappings":"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"}