{"version":3,"file":"index-DQ2Q4l-j.js","sources":["../../script.js"],"sourcesContent":["// CipherWave - Secure P2P Messenger\n// script.js\n\n// DOM Elements\nconst modeSelection = document.getElementById('mode-selection');\nconst nodePanel = document.getElementById('node-panel');\nconst connectionPanel = document.getElementById('connection-panel');\nconst chatPanel = document.getElementById('chat-panel');\nconst debugPanel = document.getElementById('debug-panel');\nconst hostNodeBtn = document.getElementById('host-node-btn');\nconst joinNetworkBtn = document.getElementById('join-network-btn');\nconst nodePortInput = document.getElementById('node-port');\nconst startNodeBtn = document.getElementById('start-node-btn');\nconst stopNodeBtn = document.getElementById('stop-node-btn');\nconst nodeStatus = document.getElementById('node-status');\nconst roomInput = document.getElementById('room-id');\nconst generateRoomBtn = document.getElementById('generate-room');\nconst cipherSelect = document.getElementById('cipher-select');\nconst connectBtn = document.getElementById('connect-btn');\nconst disconnectBtn = document.getElementById('disconnect-btn');\nconst connectionStatus = document.getElementById('connection-status');\nconst messagesContainer = document.getElementById('messages');\nconst messageInput = document.getElementById('message-input');\nconst sendBtn = document.getElementById('send-btn');\nconst chatToggle = document.getElementById('chat-toggle');\nconst debugToggle = document.getElementById('debug-toggle');\nconst debugLogs = document.getElementById('debug-logs');\nconst clearLogsBtn = document.getElementById('clear-logs-btn');\nconst runDebugBtn = document.getElementById('run-debug-btn');\nconst userIdDisplay = document.getElementById('user-id-display');\nconst peerStatus = document.getElementById('peer-status');\n\n// Application State\nlet peerConnection = null;\nlet dataChannel = null;\nlet isConnected = false;\nlet isInitiator = false;\nlet currentCipher = 'aes';\nlet encryptionKey = null;\nlet room = null;\nlet nodeServer = null;\nlet signalingSocket = null;\nlet pendingMessages = new Map(); // For message delivery confirmations\nlet messageCounter = 0;\nlet userId = null;\n\n// Configuration for WebRTC with fallback options\nconst configuration = {\n    iceServers: [\n        // STUN servers\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun.stunprotocol.org:3478' },\n        { urls: 'stun:stun.voiparound.com' },\n        { urls: 'stun:stun.voipbuster.com' },\n        { urls: 'stun:stun.voipstunt.com' },\n        { urls: 'stun:stun.xten.com' },\n        \n        // TURN servers (for better NAT traversal)\n        { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },\n        { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },\n        { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' },\n        \n        // Fallback TURN servers\n        { urls: 'turn:freeturn.net:3478', username: 'free', credential: 'free' },\n        { urls: 'turn:freeturn.net:5349', username: 'free', credential: 'free' },\n        { urls: 'turns:freeturn.net:5349', username: 'free', credential: 'free' },\n        \n        // Additional public TURN servers for testing\n        { urls: 'turn:turn.anyfirewall.com:443?transport=tcp', username: 'webrtc', credential: 'webrtc' },\n        { urls: 'turn:turn.bistri.com:80', username: 'homeo', credential: 'homeo' }\n    ],\n    iceCandidatePoolSize: 10,\n    iceTransportPolicy: 'all',\n    bundlePolicy: 'max-bundle',\n    rtcpMuxPolicy: 'require'\n};\n\n// Function to validate TURN server credentials\nfunction validateTurnCredentials(iceServers) {\n    return iceServers.map(server => {\n        if (server.urls.startsWith('turn:') && (!server.username || !server.credential)) {\n            console.warn('TURN server missing credentials:', server.urls);\n            // Remove the server from the list if credentials are missing\n            return null;\n        }\n        return server;\n    }).filter(server => server !== null);\n}\n\n// Validate and filter ICE servers\nconst validatedIceServers = validateTurnCredentials(configuration.iceServers);\nconfiguration.iceServers = validatedIceServers;\n\n// Connection timeout values\nconst CONNECTION_TIMEOUT = 60000; // 60 seconds\nconst ICE_TIMEOUT = 30000; // 30 seconds\n\n// Connection state tracking for debugging\nlet connectionStateLog = [];\n\n// List of known signaling servers for automatic discovery\nconst knownServers = [\n    'ws://localhost:52178',\n    'ws://localhost:8081',\n    'ws://localhost:8082'\n];\n\n// WebSocket signaling for peer connection\nconst signaling = {\n    connect: function(serverUrl, roomId) {\n        return new Promise((resolve, reject) => {\n            signalingSocket = new WebSocket(serverUrl);\n            signalingSocket.onopen = () => {\n                signalingSocket.send(JSON.stringify({ type: 'join', room: roomId }));\n                resolve();\n            };\n            signalingSocket.onerror = (err) => {\n                console.error('Signaling socket error:', err);\n                reject(err);\n            };\n        });\n    },\n    send: function(message) {\n        if (signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {\n            signalingSocket.send(JSON.stringify({ ...message, room }));\n        }\n    },\n    onMessage: function(callback) {\n        if (signalingSocket) {\n            signalingSocket.onmessage = (event) => {\n                try {\n                    const data = JSON.parse(event.data);\n                    callback(data);\n                } catch (e) {\n                    console.error('Signaling message parse error:', e);\n                }\n            };\n        }\n    },\n    disconnect: function() {\n        if (signalingSocket) {\n            signalingSocket.close();\n            signalingSocket = null;\n        }\n    }\n};\n\n// Node server management\nconst nodeManager = {\n    start: function(port) {\n        // In a browser environment, we can't actually start a server\n        // This would require a separate Node.js process\n        // For demo purposes, we'll simulate node hosting\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                // Simulate starting a node\n                updateNodeStatus('Node Running on port ' + port, 'status-running');\n                startNodeBtn.disabled = true;\n                stopNodeBtn.disabled = false;\n                resolve();\n            }, 1000);\n        });\n    },\n    stop: function() {\n        // Simulate stopping a node\n        updateNodeStatus('Node Stopped', 'status-stopped');\n        startNodeBtn.disabled = false;\n        stopNodeBtn.disabled = true;\n    }\n};\n\n// Automatic server discovery\nasync function discoverServer(roomId) {\n    updateConnectionStatus('Discovering network...', 'status-disconnected');\n    \n    // Try each known server until one works\n    for (const server of knownServers) {\n        try {\n            updateConnectionStatus(`Trying ${server}...`, 'status-disconnected');\n            await signaling.connect(server, roomId);\n            return server;\n        } catch (err) {\n            console.log(`Failed to connect to ${server}`);\n            continue;\n        }\n    }\n    \n    throw new Error('No available signaling servers found');\n}\n\n// Generate a random room ID\nfunction generateRoomId() {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let roomId = '';\n    for (let i = 0; i < 20; i++) {\n        roomId += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return roomId;\n}\n\n// Generate a unique user ID\nfunction generateUserId() {\n    const prefix = 'CW';\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let id = prefix + '-';\n    for (let i = 0; i < 6; i++) {\n        id += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return id;\n}\n\n// Update node status display\nfunction updateNodeStatus(text, className) {\n    nodeStatus.textContent = text;\n    nodeStatus.className = className;\n}\n\n// Update connection status display\nfunction updateConnectionStatus(text, className) {\n    connectionStatus.textContent = text;\n    connectionStatus.className = className;\n    \n    // Update peer status in chat header\n    if (peerStatus) {\n        peerStatus.textContent = text;\n        if (className.includes('connected')) {\n            peerStatus.style.color = '#4CAF50';\n        } else if (className.includes('disconnected')) {\n            peerStatus.style.color = '#F44336';\n        } else {\n            peerStatus.style.color = '#FF9800';\n        }\n    }\n}\n\n// Mode selection\nhostNodeBtn.addEventListener('click', () => {\n    modeSelection.classList.add('hidden');\n    nodePanel.classList.remove('hidden');\n});\n\njoinNetworkBtn.addEventListener('click', () => {\n    modeSelection.classList.add('hidden');\n    connectionPanel.classList.remove('hidden');\n});\n\n// Node management\nstartNodeBtn.addEventListener('click', async () => {\n    const port = nodePortInput.value || 8080;\n    updateNodeStatus('Starting node...', 'status-stopped');\n    try {\n        await nodeManager.start(port);\n    } catch (err) {\n        updateNodeStatus('Failed to start node', 'status-stopped');\n    }\n});\n\nstopNodeBtn.addEventListener('click', () => {\n    nodeManager.stop();\n});\n\n// Generate room ID on button click\ngenerateRoomBtn.addEventListener('click', () => {\n    roomInput.value = generateRoomId();\n});\n\n// Update cipher selection\ncipherSelect.addEventListener('change', () => {\n    currentCipher = cipherSelect.value;\n});\n\n// Connect to room\nconnectBtn.addEventListener('click', async () => {\n    room = roomInput.value.trim();\n    if (!room) {\n        alert('Please enter or generate a room ID');\n        return;\n    }\n\n    // Set connection status\n    updateConnectionStatus('Discovering network...', 'status-disconnected');\n\n    // Discover and connect to signaling server\n    let serverUrl;\n    try {\n        serverUrl = await discoverServer(room);\n    } catch (err) {\n        updateConnectionStatus('No available servers', 'status-disconnected');\n        return;\n    }\n\n    // Initialize encryption\n    await initializeEncryption();\n\n    // Set up signaling message handler\n    signaling.onMessage((msg) => {\n        if (msg.type === 'init') {\n            isInitiator = msg.initiator;\n            // Start WebRTC connection after receiving init message\n            startConnection();\n        } else if (msg.type === 'key') {\n            // Handle key exchange message\n            handleKeyExchange(msg);\n        } else {\n            handleSignalingMessage(msg);\n        }\n    });\n});\n\n// Log connection state for debugging\nfunction logConnectionState(state) {\n    const timestamp = new Date().toLocaleTimeString();\n    connectionStateLog.push(`${timestamp}: ${state}`);\n    console.log(`[Connection Log] ${timestamp}: ${state}`);\n    \n    // Update debug panel in real-time\n    if (typeof debugLogs !== 'undefined' && debugLogs) {\n        const logEntry = document.createElement('div');\n        logEntry.className = 'debug-log-entry';\n        logEntry.textContent = `[${timestamp}] ${state}`;\n        debugLogs.appendChild(logEntry);\n        \n        // Scroll to bottom\n        debugLogs.scrollTop = debugLogs.scrollHeight;\n    }\n}\n\n// Start WebRTC connection\nfunction startConnection() {\n    try {\n        // Update connection status\n        updateConnectionStatus('Establishing peer connection...', 'status-disconnected');\n        logConnectionState('Starting WebRTC connection setup');\n        \n        // Create peer connection\n        peerConnection = new RTCPeerConnection(configuration);\n        logConnectionState('RTCPeerConnection created');\n        \n        // Set up connection timeout\n        const connectionTimeout = setTimeout(() => {\n            if (peerConnection.connectionState !== 'connected' && \n                peerConnection.connectionState !== 'completed') {\n                logConnectionState('Connection timeout - no connection established');\n                updateConnectionStatus('Connection timeout', 'status-disconnected');\n                \n                // Try to restart ICE if connection is still trying\n                if (peerConnection.iceConnectionState === 'checking' || \n                    peerConnection.iceConnectionState === 'disconnected') {\n                    logConnectionState('Attempting ICE restart after timeout');\n                    peerConnection.restartIce();\n                }\n            }\n        }, CONNECTION_TIMEOUT);\n        \n        // Log connection state changes\n        peerConnection.onconnectionstatechange = () => {\n            logConnectionState(`Connection state: ${peerConnection.connectionState}`);\n            updateConnectionStatus(`Connection: ${peerConnection.connectionState}`, 'status-disconnected');\n            \n            // Clear timeout if connection is established\n            if (peerConnection.connectionState === 'connected' || \n                peerConnection.connectionState === 'completed') {\n                clearTimeout(connectionTimeout);\n            }\n            \n            // Handle connection failure\n            if (peerConnection.connectionState === 'failed') {\n                logConnectionState('Connection failed, attempting to restart ICE');\n                peerConnection.restartIce();\n            }\n            \n            // Handle disconnected state\n            if (peerConnection.connectionState === 'disconnected') {\n                logConnectionState('Connection disconnected, monitoring for reconnection');\n                // Set a timeout to restart ICE if we don't reconnect quickly\n                setTimeout(() => {\n                    if (peerConnection.connectionState === 'disconnected') {\n                        logConnectionState('Connection still disconnected, attempting to restart ICE');\n                        peerConnection.restartIce();\n                    }\n                }, 10000);\n            }\n        };\n        \n        peerConnection.onsignalingstatechange = () => {\n            logConnectionState(`Signaling state: ${peerConnection.signalingState}`);\n        };\n        \n        peerConnection.oniceconnectionstatechange = () => {\n            logConnectionState(`ICE connection state: ${peerConnection.iceConnectionState}`);\n            \n            // Handle ICE connection failure\n            if (peerConnection.iceConnectionState === 'failed') {\n                logConnectionState('ICE connection failed, attempting to restart ICE');\n                peerConnection.restartIce();\n            }\n            \n            // Handle ICE disconnection\n            if (peerConnection.iceConnectionState === 'disconnected') {\n                logConnectionState('ICE connection disconnected, monitoring for reconnection');\n            }\n        };\n        \n        peerConnection.onicegatheringstatechange = () => {\n            logConnectionState(`ICE gathering state: ${peerConnection.iceGatheringState}`);\n            \n            // Set ICE gathering timeout\n            if (peerConnection.iceGatheringState === 'gathering') {\n                setTimeout(() => {\n                    if (peerConnection.iceGatheringState === 'gathering') {\n                        logConnectionState('ICE gathering timeout - forcing completion');\n                        // Force completion by creating a null candidate\n                        peerConnection.onicecandidate({ candidate: null });\n                    }\n                }, ICE_TIMEOUT);\n            }\n        };\n        \n        // Handle ICE candidates with better error handling\n        peerConnection.onicecandidate = event => {\n            if (event.candidate) {\n                logConnectionState(`ICE candidate gathered: ${event.candidate.type} (${event.candidate.protocol})`);\n                signaling.send({\n                    type: 'candidate',\n                    candidate: event.candidate\n                });\n            } else {\n                logConnectionState('ICE candidate gathering complete');\n            }\n        };\n        \n        // Handle ICE candidate errors with fallback\n        peerConnection.onicecandidateerror = event => {\n            logConnectionState(`ICE candidate error: ${event.errorCode} - ${event.errorText} (${event.url})`);\n            console.error('ICE candidate error:', event);\n            \n            // Try to continue with available candidates\n            if (peerConnection.iceGatheringState === 'complete') {\n                logConnectionState('ICE gathering completed despite errors');\n            }\n            \n            // If we're still gathering, try to restart ICE after a delay\n            if (peerConnection.iceGatheringState === 'gathering') {\n                logConnectionState('Attempting to restart ICE after candidate error');\n                setTimeout(() => {\n                    if (peerConnection.iceGatheringState === 'gathering') {\n                        logConnectionState('Forcing ICE gathering completion after error');\n                        // Force completion by creating a null candidate\n                        peerConnection.onicecandidate({ candidate: null });\n                    }\n                }, 5000);\n            }\n        };\n        \n        // Handle data channel\n        if (isInitiator) {\n            logConnectionState('Creating data channel (initiator)');\n            // Create data channel for initiator with better configuration\n            dataChannel = peerConnection.createDataChannel('messaging', {\n                ordered: true,\n                maxRetransmits: 3\n            });\n            setupDataChannel(dataChannel);\n            \n            // Create offer with better configuration\n            logConnectionState('Creating offer');\n            peerConnection.createOffer({\n                offerToReceiveAudio: false,\n                offerToReceiveVideo: false\n            })\n                .then(offer => {\n                    logConnectionState('Offer created, setting local description');\n                    return peerConnection.setLocalDescription(offer);\n                })\n                .then(() => {\n                    logConnectionState('Local description set, sending offer');\n                    signaling.send({\n                        type: 'offer',\n                        offer: peerConnection.localDescription\n                    });\n                })\n                .catch(error => {\n                    logConnectionState(`Error creating offer: ${error.message}`);\n                    console.error('Error creating offer:', error);\n                    updateConnectionStatus('Connection failed', 'status-disconnected');\n                });\n        } else {\n            logConnectionState('Waiting for data channel (non-initiator)');\n            // Handle incoming data channel for non-initiator with better configuration\n            peerConnection.ondatachannel = event => {\n                logConnectionState('Data channel received');\n                dataChannel = event.channel;\n                dataChannel.binaryType = 'arraybuffer';\n                setupDataChannel(dataChannel);\n            };\n        }\n        \n    } catch (error) {\n        logConnectionState(`Error starting connection: ${error.message}`);\n        console.error('Error starting connection:', error);\n        updateConnectionStatus('Connection failed', 'status-disconnected');\n    }\n}\n\n// Handle signaling messages\nfunction handleSignalingMessage(message) {\n    if (!peerConnection) {\n        logConnectionState('Received signaling message but no peer connection exists');\n        return;\n    }\n    \n    logConnectionState(`Received signaling message: ${message.type}`);\n    \n    switch (message.type) {\n        case 'offer':\n            logConnectionState('Processing offer');\n            peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer))\n                .then(() => {\n                    logConnectionState('Remote offer set, creating answer');\n                    return peerConnection.createAnswer();\n                })\n                .then(answer => {\n                    logConnectionState('Answer created, setting local description');\n                    return peerConnection.setLocalDescription(answer);\n                })\n                .then(() => {\n                    logConnectionState('Local answer set, sending answer');\n                    signaling.send({\n                        type: 'answer',\n                        answer: peerConnection.localDescription\n                    });\n                })\n                .catch(error => {\n                    logConnectionState(`Error handling offer: ${error.message}`);\n                    console.error('Error handling offer:', error);\n                });\n            break;\n            \n        case 'answer':\n            logConnectionState('Processing answer');\n            peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer))\n                .then(() => {\n                    logConnectionState('Remote answer set successfully');\n                })\n                .catch(error => {\n                    logConnectionState(`Error handling answer: ${error.message}`);\n                    console.error('Error handling answer:', error);\n                });\n            break;\n            \n        case 'candidate':\n            logConnectionState(`Adding ICE candidate: ${message.candidate.type}`);\n            peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate))\n                .then(() => {\n                    logConnectionState('ICE candidate added successfully');\n                })\n                .catch(error => {\n                    logConnectionState(`Error adding ICE candidate: ${error.message}`);\n                    console.error('Error adding ICE candidate:', error);\n                });\n            break;\n            \n        default:\n            logConnectionState(`Unknown signaling message type: ${message.type}`);\n    }\n}\n\n// Setup data channel\nfunction setupDataChannel(channel) {\n    channel.onopen = () => {\n        isConnected = true;\n        updateConnectionStatus('Connected', 'status-connected');\n        connectBtn.disabled = true;\n        disconnectBtn.disabled = false;\n        \n        // Show chat panel\n        connectionPanel.classList.add('hidden');\n        chatPanel.classList.remove('hidden');\n    };\n    \n    channel.onclose = () => {\n        isConnected = false;\n        updateConnectionStatus('Disconnected', 'status-disconnected');\n        connectBtn.disabled = false;\n        disconnectBtn.disabled = true;\n        \n        // Show connection panel\n        chatPanel.classList.add('hidden');\n        connectionPanel.classList.remove('hidden');\n    };\n    \n    channel.onerror = (error) => {\n        logConnectionState(`Data channel error: ${error.message}`);\n        console.error('Data channel error:', error);\n        \n        // If we're still connected, try to restart the data channel\n        if (isConnected) {\n            logConnectionState('Attempting to restart data channel after error');\n            isConnected = false;\n            updateConnectionStatus('Data channel error, reconnecting...', 'status-disconnected');\n            \n            // Try to restart the connection after a short delay\n            setTimeout(() => {\n                if (peerConnection && peerConnection.connectionState !== 'connected') {\n                    logConnectionState('Restarting ICE after data channel error');\n                    peerConnection.restartIce();\n                }\n            }, 2000);\n        }\n    };\n    \n    channel.onmessage = event => {\n        try {\n            const data = JSON.parse(event.data);\n            if (data.type === 'message') {\n                // Decrypt message\n                const decryptedMessage = decryptMessage(data.content, currentCipher);\n                displayMessage(decryptedMessage, 'received');\n            } else if (data.type === 'delivery-confirmation') {\n                // Handle message delivery confirmation\n                const messageElement = document.querySelector(`[data-message-id=\"${data.messageId}\"]`);\n                if (messageElement) {\n                    const statusElement = messageElement.querySelector('.message-status');\n                    if (statusElement) {\n                        statusElement.textContent = '✓✓';\n                        statusElement.className = 'message-status delivered';\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('Error processing message:', error);\n        }\n    };\n}\n\n// Disconnect from room\ndisconnectBtn.addEventListener('click', () => {\n    if (dataChannel) {\n        dataChannel.close();\n    }\n    if (peerConnection) {\n        peerConnection.close();\n    }\n\n    signaling.disconnect();\n\n    isConnected = false;\n    updateConnectionStatus('Disconnected', 'status-disconnected');\n    connectBtn.disabled = false;\n    disconnectBtn.disabled = true;\n\n    // Show connection panel\n    chatPanel.classList.add('hidden');\n    connectionPanel.classList.remove('hidden');\n\n    // Clear messages\n    messagesContainer.innerHTML = '';\n    \n    // Clear pending messages\n    pendingMessages.clear();\n});\n\n// Send message\nsendBtn.addEventListener('click', sendMessage);\nmessageInput.addEventListener('keypress', (e) => {\n    if (e.key === 'Enter') {\n        sendMessage();\n    }\n});\n\n// Send message function\nfunction sendMessage() {\n    const message = messageInput.value.trim();\n    if (!message || !isConnected || !dataChannel) return;\n    \n    try {\n        // Encrypt message\n        const encryptedMessage = encryptMessage(message, currentCipher);\n        \n        // Create message ID for tracking\n        const messageId = ++messageCounter;\n        \n        // Send via data channel\n        const messageData = {\n            type: 'message',\n            content: encryptedMessage,\n            timestamp: Date.now(),\n            messageId: messageId\n        };\n        \n        dataChannel.send(JSON.stringify(messageData));\n        displayMessage(message, 'sent', messageId);\n        messageInput.value = '';\n        \n        // Track pending message for delivery confirmation\n        pendingMessages.set(messageId, {\n            content: message,\n            timestamp: Date.now()\n        });\n        \n        // Set timeout for delivery confirmation\n        setTimeout(() => {\n            if (pendingMessages.has(messageId)) {\n                const messageElement = document.querySelector(`[data-message-id=\"${messageId}\"]`);\n                if (messageElement) {\n                    const statusElement = messageElement.querySelector('.message-status');\n                    if (statusElement && statusElement.textContent === '✓') {\n                        statusElement.textContent = '⚠';\n                        statusElement.className = 'message-status not-delivered';\n                    }\n                }\n                pendingMessages.delete(messageId);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('Error sending message:', error);\n        alert('Failed to send message');\n    }\n}\n\n// Display message in UI\nfunction displayMessage(message, type, messageId = null) {\n    const messageElement = document.createElement('div');\n    messageElement.className = `message ${type}`;\n    \n    if (messageId) {\n        messageElement.setAttribute('data-message-id', messageId);\n    }\n    \n    const messageContent = document.createElement('div');\n    messageContent.className = 'message-content';\n    messageContent.textContent = message;\n    \n    const messageInfo = document.createElement('div');\n    messageInfo.className = 'message-info';\n    messageInfo.textContent = new Date().toLocaleTimeString();\n    \n    // Add delivery status indicator for sent messages\n    if (type === 'sent') {\n        const statusElement = document.createElement('span');\n        statusElement.className = 'message-status';\n        statusElement.textContent = '✓';\n        messageInfo.appendChild(statusElement);\n    }\n    \n    messageElement.appendChild(messageContent);\n    messageElement.appendChild(messageInfo);\n    messagesContainer.appendChild(messageElement);\n    \n    // Scroll to bottom\n    messagesContainer.scrollTop = messagesContainer.scrollHeight;\n}\n\n// Initialize encryption based on selected cipher\nasync function initializeEncryption() {\n    switch (currentCipher) {\n        case 'aes':\n            // Generate a random key for AES\n            encryptionKey = CryptoJS.lib.WordArray.random(256/8);\n            break;\n        case 'rsa':\n            // In a real implementation, we would generate RSA keys\n            // For demo, we'll use a placeholder\n            encryptionKey = 'rsa-key-placeholder';\n            break;\n        case 'chacha20':\n            // Generate a random key for ChaCha20\n            encryptionKey = CryptoJS.lib.WordArray.random(256/8);\n            break;\n    }\n    \n    // For demo purposes, we'll share the key through the signaling channel\n    // In a real implementation, this would be done through a secure key exchange\n    if (isInitiator) {\n        setTimeout(() => {\n            signaling.send({\n                type: 'key',\n                cipher: currentCipher,\n                key: encryptionKey.toString()\n            });\n        }, 2000);\n    }\n}\n\n// Handle incoming key exchange messages\nfunction handleKeyExchange(message) {\n    if (message.type === 'key') {\n        // Set the encryption key received from the initiator\n        encryptionKey = CryptoJS.enc.Hex.parse(message.key);\n        logConnectionState(`Encryption key received for ${message.cipher}`);\n    }\n}\n\n// Encrypt message based on selected cipher\nfunction encryptMessage(message, cipher) {\n    switch (cipher) {\n        case 'aes':\n            return CryptoJS.AES.encrypt(message, encryptionKey).toString();\n        case 'rsa':\n            // In a real implementation, we would use RSA encryption\n            // For demo, we'll just base64 encode\n            return btoa(message);\n        case 'chacha20':\n            // ChaCha20 implementation would go here\n            // For demo, we'll use AES as a substitute\n            return CryptoJS.AES.encrypt(message, encryptionKey).toString();\n        default:\n            return message;\n    }\n}\n\n// Decrypt message based on selected cipher\nfunction decryptMessage(encryptedMessage, cipher) {\n    try {\n        switch (cipher) {\n            case 'aes':\n                const decrypted = CryptoJS.AES.decrypt(encryptedMessage, encryptionKey);\n                return decrypted.toString(CryptoJS.enc.Utf8);\n            case 'rsa':\n                // In a real implementation, we would use RSA decryption\n                // For demo, we'll just base64 decode\n                return atob(encryptedMessage);\n            case 'chacha20':\n                // ChaCha20 implementation would go here\n                // For demo, we'll use AES as a substitute\n                const chachaDecrypted = CryptoJS.AES.decrypt(encryptedMessage, encryptionKey);\n                return chachaDecrypted.toString(CryptoJS.enc.Utf8);\n            default:\n                return encryptedMessage;\n        }\n    } catch (error) {\n        console.error('Decryption error:', error);\n        return '[Decryption Error]';\n    }\n}\n\n// Initialize the application\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Set initial states\n    updateNodeStatus('Node Stopped', 'status-stopped');\n    updateConnectionStatus('Disconnected', 'status-disconnected');\n    \n    // Generate a room ID by default\n    roomInput.value = generateRoomId();\n    \n    // Generate and display user ID\n    userId = generateUserId();\n    if (userIdDisplay) {\n        userIdDisplay.textContent = userId;\n    }\n    \n    // Show debug panel\n    debugPanel.classList.remove('hidden');\n});\n\n// Expandable panel functionality\nchatToggle.addEventListener('click', () => {\n    const content = document.querySelector('#messages');\n    if (content.style.display === 'none') {\n        content.style.display = 'block';\n        chatToggle.textContent = '▼';\n    } else {\n        content.style.display = 'none';\n        chatToggle.textContent = '▶';\n    }\n});\n\ndebugToggle.addEventListener('click', () => {\n    const content = document.querySelector('#debug-content');\n    if (content.style.display === 'none') {\n        content.style.display = 'block';\n        debugToggle.textContent = '▼';\n    } else {\n        content.style.display = 'none';\n        debugToggle.textContent = '▶';\n    }\n});\n\n// Debug panel functionality\nclearLogsBtn.addEventListener('click', () => {\n    debugLogs.innerHTML = '';\n    connectionStateLog = [];\n});\n\nrunDebugBtn.addEventListener('click', () => {\n    // Run the debug connection function\n    debugConnection();\n});\n\n// Enhanced debug connection function\nfunction debugConnection() {\n    const logEntry = document.createElement('div');\n    logEntry.className = 'debug-log-entry';\n    \n    let debugInfo = `=== CipherWave Debug Report ===\\n`;\n    debugInfo += `Time: ${new Date().toLocaleString()}\\n`;\n    debugInfo += `User ID: ${userId || 'Not generated'}\\n\\n`;\n    \n    // Check if required APIs are available\n    debugInfo += `WebRTC Support: ${!!window.RTCPeerConnection}\\n`;\n    debugInfo += `WebSocket Support: ${!!window.WebSocket}\\n`;\n    debugInfo += `Crypto Support: ${!!window.crypto}\\n\\n`;\n    \n    // Check network connectivity\n    debugInfo += `Online Status: ${navigator.onLine}\\n\\n`;\n    \n    // Check signaling server connection\n    if (typeof signalingSocket !== 'undefined' && signalingSocket) {\n        debugInfo += `Signaling Server Status: ${signalingSocket.readyState}\\n`;\n        debugInfo += `Signaling Server URL: ${signalingSocket.url || 'N/A'}\\n\\n`;\n    } else {\n        debugInfo += `Signaling Server: Not connected\\n\\n`;\n    }\n    \n    // Check WebRTC connection\n    if (typeof peerConnection !== 'undefined' && peerConnection) {\n        debugInfo += `Peer Connection State: ${peerConnection.connectionState}\\n`;\n        debugInfo += `Signaling State: ${peerConnection.signalingState}\\n`;\n        debugInfo += `ICE Connection State: ${peerConnection.iceConnectionState}\\n`;\n        debugInfo += `ICE Gathering State: ${peerConnection.iceGatheringState}\\n\\n`;\n    } else {\n        debugInfo += `Peer Connection: Not established\\n\\n`;\n    }\n    \n    // Check data channel\n    if (typeof dataChannel !== 'undefined' && dataChannel) {\n        debugInfo += `Data Channel State: ${dataChannel.readyState}\\n`;\n        debugInfo += `Data Channel Label: ${dataChannel.label}\\n\\n`;\n    } else {\n        debugInfo += `Data Channel: Not established\\n\\n`;\n    }\n    \n    // Display connection log\n    if (typeof connectionStateLog !== 'undefined' && connectionStateLog && connectionStateLog.length > 0) {\n        debugInfo += `=== Recent Connection Events ===\\n`;\n        // Show last 10 log entries\n        const recentLogs = connectionStateLog.slice(-10);\n        debugInfo += recentLogs.join('\\n');\n    } else {\n        debugInfo += `=== No Connection Events ===\\n`;\n    }\n    \n    debugInfo += `\\n=== End Debug Report ===`;\n    \n    logEntry.textContent = debugInfo;\n    debugLogs.appendChild(logEntry);\n    \n    // Scroll to bottom\n    debugLogs.scrollTop = debugLogs.scrollHeight;\n}\n"],"names":["modeSelection","document","getElementById","nodePanel","connectionPanel","chatPanel","debugPanel","hostNodeBtn","joinNetworkBtn","nodePortInput","startNodeBtn","stopNodeBtn","nodeStatus","roomInput","generateRoomBtn","cipherSelect","connectBtn","disconnectBtn","connectionStatus","messagesContainer","messageInput","sendBtn","chatToggle","debugToggle","debugLogs","clearLogsBtn","runDebugBtn","userIdDisplay","peerStatus","peerConnection","dataChannel","isConnected","isInitiator","currentCipher","encryptionKey","room","signalingSocket","pendingMessages","Map","messageCounter","userId","configuration","iceServers","urls","username","credential","iceCandidatePoolSize","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","validatedIceServers","map","server","startsWith","console","warn","filter","connectionStateLog","knownServers","signaling","serverUrl","roomId","Promise","resolve","reject","WebSocket","onopen","send","JSON","stringify","type","onerror","err","error","message","readyState","OPEN","callback","onmessage","event","data","parse","e","close","nodeManager","port","setTimeout","updateNodeStatus","disabled","generateRoomId","chars","i","charAt","Math","floor","random","text","className","textContent","updateConnectionStatus","includes","style","color","logConnectionState","state","timestamp","Date","toLocaleTimeString","push","concat","log","logEntry","createElement","appendChild","scrollTop","scrollHeight","setupDataChannel","channel","classList","add","remove","onclose","connectionState","restartIce","displayMessage","encryptedMessage","cipher","CryptoJS","AES","decrypt","toString","enc","Utf8","atob","decryptMessage","content","messageElement","querySelector","messageId","statusElement","sendMessage","value","trim","encrypt","btoa","encryptMessage","messageData","now","set","has","delete","alert","setAttribute","messageContent","messageInfo","addEventListener","async","Error","discoverServer","lib","WordArray","key","initializeEncryption","msg","initiator","RTCPeerConnection","connectionTimeout","iceConnectionState","onconnectionstatechange","clearTimeout","onsignalingstatechange","signalingState","oniceconnectionstatechange","onicegatheringstatechange","iceGatheringState","onicecandidate","candidate","protocol","onicecandidateerror","errorCode","errorText","url","createDataChannel","ordered","maxRetransmits","createOffer","offerToReceiveAudio","offerToReceiveVideo","then","offer","setLocalDescription","localDescription","catch","ondatachannel","binaryType","startConnection","Hex","setRemoteDescription","RTCSessionDescription","createAnswer","answer","addIceCandidate","RTCIceCandidate","handleSignalingMessage","innerHTML","clear","id","prefix","generateUserId","display","debugInfo","toLocaleString","window","crypto","onLine","label","length","slice","join","debugConnection"],"mappings":"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"}